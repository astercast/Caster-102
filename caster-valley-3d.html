<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>üßô‚Äç‚ôÇÔ∏è Caster Valley 3D</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Nunito:wght@400;600;700;800&display=swap');
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        :root {
            --cream: #fef6e4; --sand: #f3d5b5; --brown-light: #8b6f47; --brown-med: #6d5633;
            --brown-dark: #533d2b; --green-light: #b8d48e; --green-med: #7ba05b; --green-dark: #5a7647;
            --blue-sky: #87ceeb; --orange: #f4a261; --red: #c9562c; --gold: #ffd700; --purple: #9d84b7;
        }
        body {
            font-family: 'Nunito', sans-serif; background: linear-gradient(180deg, var(--blue-sky) 0%, var(--green-light) 100%);
            color: var(--brown-dark); overflow: hidden; height: 100vh; touch-action: none;
            transition: background 1.5s ease; /* Smooth day/night transition */
        }
        body.night-mode {
            background: linear-gradient(180deg, #1a1a3e 0%, #0f1a2e 100%);
        }
        #game-container { position: relative; width: 100%; height: 100vh; display: flex; flex-direction: column; }
        #hud {
            background: linear-gradient(180deg, var(--brown-light) 0%, var(--brown-med) 100%); border-bottom: 4px solid var(--brown-dark);
            box-shadow: 0 4px 0 var(--brown-dark), inset 0 2px 0 var(--sand); padding: 12px; display: grid; grid-template-columns: 1fr auto 1fr; gap: 15px; align-items: center; z-index: 100;
        }
        .hud-left, .hud-right { display: flex; flex-direction: column; gap: 8px; }
        .hud-center { text-align: center; }
        .stat-row { display: flex; align-items: center; gap: 8px; font-size: 10px; }
        .stat-icon { font-size: 24px; filter: drop-shadow(2px 2px 0 rgba(0,0,0,0.3)); }
        .bar-container {
            flex: 1; height: 22px; background: var(--brown-dark); border: 3px solid var(--sand); border-radius: 6px; overflow: hidden;
            position: relative; box-shadow: inset 0 3px 8px rgba(0, 0, 0, 0.5);
        }
        .bar-fill { height: 100%; transition: width 0.4s ease; position: relative; }
        .bar-fill::before { content: ''; position: absolute; top: 0; left: 0; right: 0; height: 40%; background: linear-gradient(180deg, rgba(255, 255, 255, 0.4) 0%, transparent 100%); }
        .hp-bar { background: linear-gradient(90deg, #c9562c 0%, #f4a261 100%); }
        .xp-bar { background: linear-gradient(90deg, #9d84b7 0%, #d0c4e3 100%); }
        .bar-text {
            font-family: 'Press Start 2P', cursive; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 7px; color: var(--cream);
            text-shadow: 2px 2px 0 var(--brown-dark); z-index: 1;
        }
        .wizard-level {
            font-family: 'Press Start 2P', cursive; font-size: 20px; color: var(--gold); text-shadow: 3px 3px 0 var(--brown-dark);
            animation: shine 2s ease-in-out infinite; margin-bottom: 6px;
        }
        @keyframes shine { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); } }
        .resource-display { font-family: 'Press Start 2P', cursive; font-size: 11px; color: var(--cream); text-shadow: 2px 2px 0 var(--brown-dark); display: flex; align-items: center; justify-content: center; gap: 6px; }
        .menu-buttons { display: flex; gap: 6px; flex-wrap: wrap; align-items: center; }
        .menu-btn {
            font-family: 'Press Start 2P', cursive; background: linear-gradient(180deg, var(--brown-light) 0%, var(--brown-med) 100%); border: 3px solid var(--sand); color: var(--cream);
            padding: 8px 12px; border-radius: 6px; font-size: 7px; cursor: pointer; transition: all 0.2s ease;
            box-shadow: 0 4px 0 var(--brown-dark), inset 0 1px 0 rgba(255, 255, 255, 0.3); text-shadow: 1px 1px 0 var(--brown-dark);
            min-width: 40px; min-height: 40px; display: flex; align-items: center; justify-content: center;
        }
        .menu-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 0 var(--brown-dark); filter: brightness(1.1); }
        .menu-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 var(--brown-dark); }
        #game-world { flex: 1; position: relative; overflow: hidden; background: transparent; }
        #game-canvas { width: 100%; height: 100%; display: block; background: transparent; }
        #toolbar {
            background: linear-gradient(0deg, var(--brown-light) 0%, var(--brown-med) 100%); border-top: 4px solid var(--brown-dark);
            box-shadow: 0 -4px 0 var(--brown-dark), inset 0 -2px 0 var(--sand); padding: 6px; display: flex; gap: 6px; overflow-x: auto; z-index: 100;
        }
        .tool-item, .seed-item, .area-btn {
            flex: 0 1 auto; min-width: 55px; max-width: 70px; height: 65px; background: linear-gradient(135deg, var(--sand) 0%, var(--brown-light) 100%);
            border: 3px solid var(--brown-dark); border-radius: 8px; display: flex; flex-direction: column; align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s ease; padding: 4px; box-shadow: 0 4px 0 var(--brown-dark), inset 0 2px 0 rgba(255, 255, 255, 0.3);
        }
        .tool-item:active, .seed-item:active, .area-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 var(--brown-dark); }
        .tool-icon, .seed-icon { font-size: 24px; margin-bottom: 2px; filter: drop-shadow(2px 2px 0 rgba(0,0,0,0.3)); }
        .tool-label, .seed-label {
            font-family: 'Press Start 2P', cursive; font-size: 6px; text-align: center; line-height: 1.2; text-transform: uppercase;
            color: var(--brown-dark); text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.5);
        }
        .seed-count {
            position: absolute; top: 2px; right: 2px; background: var(--red); color: var(--cream); border-radius: 50%;
            min-width: 20px; height: 20px; display: flex; align-items: center; justify-content: center; font-size: 8px;
            border: 2px solid var(--brown-dark); box-shadow: 0 2px 4px rgba(0,0,0,0.3); text-shadow: 1px 1px 0 var(--brown-dark);
            font-weight: bold;
        }
        .area-btn { background: linear-gradient(135deg, var(--green-light), var(--green-med)); border-color: var(--green-dark); min-width: 62px; }
        .area-btn.active { box-shadow: 0 4px 0 var(--green-dark), 0 0 20px var(--gold), inset 0 0 20px rgba(255, 255, 255, 0.3); border-color: var(--gold); }
        
        /* Expandable Side Tabs on Right */
        .side-tab {
            position: fixed; right: 0; width: 38px; height: 48px;
            border: 3px solid var(--brown-dark); border-right: none; border-radius: 10px 0 0 10px;
            cursor: pointer; transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: -4px 0 15px rgba(0,0,0,0.5);
            z-index: 200; padding: 4px 2px;
        }
        .side-tab:hover:not(.expanded) { 
            width: 46px; box-shadow: -6px 0 18px rgba(0,0,0,0.7); transform: translateX(-2px);
        }
        .side-tab.expanded { 
            width: 42vw; min-width: 300px; max-width: 450px; height: 65vh; max-height: 550px; padding: 18px; border-radius: 10px 0 0 10px;
            cursor: default;
        }
        .side-tab.hidden { display: none; }
        #shop-tab {
            top: 90px; background: linear-gradient(135deg, #7ba05b, #5a7647);
        }
        #shop-tab:hover:not(.expanded) { background: linear-gradient(135deg, #8fb570, #6d8556); }
        #shop-tab.expanded { background: linear-gradient(135deg, var(--sand), var(--brown-light)); }
        
        #skills-tab {
            top: 150px; background: linear-gradient(135deg, #ffd700, #d4af37);
        }
        #skills-tab:hover:not(.expanded) { background: linear-gradient(135deg, #ffe44d, #e6c24d); }
        #skills-tab.expanded { background: linear-gradient(135deg, #f5e6c8, #d4af37); }
        .tab-icon {
            font-size: 22px; margin-bottom: 2px; transition: all 0.3s ease;
            filter: drop-shadow(1px 1px 2px rgba(0,0,0,0.5));
        }
        .tab-label {
            font-family: 'Press Start 2P'; font-size: 5px; color: white; text-align: center;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.8); transition: all 0.3s ease; line-height: 1.1;
        }
        .tab-icon-text {
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: all 0.3s;
        }
        .side-tab.expanded .tab-icon-text { display: none; }
        .tab-content-wrapper {
            display: none; width: 100%; height: 100%;
        }
        .side-tab.expanded .tab-content-wrapper { display: block; }
        .tab-header {
            font-family: 'Press Start 2P'; font-size: 13px; text-align: center;
            margin-bottom: 16px; color: var(--brown-dark);
        }
        .tab-content {
            display: none; width: 100%; height: calc(100% - 40px); overflow-y: auto; margin-top: 6px;
        }
        .side-tab.expanded .tab-content { display: block; }
        #shop-content {
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 8px;
        }
        .tab-close {
            position: absolute; top: 12px; right: 15px; font-size: 24px; color: white;
            cursor: pointer; display: none; font-weight: bold; line-height: 1; z-index: 10;
            text-shadow: 2px 2px 6px rgba(0,0,0,0.9); transition: all 0.2s;
        }
        .side-tab.expanded .tab-close { display: block; }
        .tab-close:hover { color: #ff6b6b; transform: scale(1.3) rotate(90deg); }
        
        /* Left Side Area Tabs */
        .left-tabs {
            position: fixed; left: 10px; top: 100px; z-index: 150;
            display: flex; flex-direction: column; gap: 8px;
        }
        .left-tab {
            width: 56px; height: 50px; background: linear-gradient(135deg, var(--green-med), var(--green-dark));
            border: 3px solid var(--brown-dark); border-radius: 10px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            transition: all 0.3s ease; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .left-tab:hover {
            transform: translateX(5px) scale(1.05); box-shadow: 0 6px 15px rgba(0,0,0,0.7);
            background: linear-gradient(135deg, var(--green-dark), #2d5016);
        }
        .left-tab.active {
            background: linear-gradient(135deg, #ffd700, #d4af37);
            transform: translateX(8px) scale(1.1); box-shadow: 0 8px 20px rgba(255,215,0,0.6);
        }
        .left-tab.locked {
            opacity: 0.4; cursor: not-allowed; background: linear-gradient(135deg, #666, #444);
        }
        .left-tab.locked:hover {
            transform: none; box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .left-tab-icon {
            font-size: 22px; filter: drop-shadow(1px 1px 3px rgba(0,0,0,0.7));
        }
        .left-tab-label {
            font-family: 'Press Start 2P'; font-size: 5px; color: white; text-align: center;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.9); margin-top: 2px;
        }
        
        .store-section { margin-bottom: 20px; }
        .store-section-title { 
            font-family: 'Press Start 2P'; font-size: 10px; margin-bottom: 12px; color: var(--brown-dark); 
            border-bottom: 3px solid var(--brown-dark); padding-bottom: 8px; 
        }
        .store-item {
            background: rgba(255,255,255,0.3); border: 2px solid var(--brown-dark); border-radius: 6px; padding: 6px;
            margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center; transition: all 0.2s;
        }
        .store-item:hover { background: rgba(255,255,255,0.5); transform: translateX(-3px); }
        .store-item-info { display: flex; align-items: center; gap: 6px; }
        .store-item-icon { font-size: 18px; }
        .store-item-details { font-size: 7px; line-height: 1.3; }
        .store-sell-btn {
            font-family: 'Press Start 2P'; background: var(--green-med); border: 2px solid var(--brown-dark);
            color: var(--cream); padding: 4px 8px; border-radius: 5px; cursor: pointer; font-size: 6px;
            box-shadow: 0 3px 0 var(--brown-dark); transition: all 0.15s;
        }
        .store-sell-btn:hover { background: var(--green-dark); transform: translateY(-1px); box-shadow: 0 4px 0 var(--brown-dark); }
        .store-sell-btn:active { transform: translateY(1px); box-shadow: 0 1px 0 var(--brown-dark); }
        
        
        .achievement-notification {
            position: fixed; left: -280px; top: 110px; width: 260px; background: linear-gradient(135deg, #ffd700, #f4a261);
            border: 3px solid var(--brown-dark); border-radius: 10px; padding: 10px; z-index: 3000;
            box-shadow: 0 6px 15px rgba(0,0,0,0.6); animation: slide-in-left 0.5s ease forwards;
        }
        @keyframes slide-in-left {
            from { left: -280px; }
            to { left: 20px; }
        }
        @keyframes slide-out-left {
            from { left: 20px; }
            to { left: -280px; }
        }
        .achievement-notification.hiding { animation: slide-out-left 0.5s ease forwards; }
        .achievement-notification-header { font-family: 'Press Start 2P'; font-size: 8px; text-align: center; margin-bottom: 8px; color: var(--brown-dark); }
        .achievement-notification-body { display: flex; align-items: center; gap: 10px; }
        .achievement-notification-icon { font-size: 36px; }
        .achievement-notification-text { flex: 1; }
        .achievement-notification-title { font-family: 'Press Start 2P'; font-size: 7px; margin-bottom: 4px; }
        .achievement-notification-reward { font-size: 9px; font-weight: bold; color: var(--gold); }
        
        .weather-notification {
            position: fixed; left: 20px; top: 200px; width: 220px; background: linear-gradient(135deg, #87ceeb, #6ba3d0);
            border: 3px solid var(--brown-dark); border-radius: 8px; padding: 8px; z-index: 2900;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); animation: fade-in 0.4s ease;
        }
        @keyframes fade-in { from { opacity: 0; transform: translateY(-20px); } to { opacity: 1; transform: translateY(0); } }
        .weather-notification-title { font-family: 'Press Start 2P'; font-size: 7px; margin-bottom: 6px; text-align: center; }
        .weather-notification-text { font-size: 9px; text-align: center; line-height: 1.4; }
        
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.85);
            display: flex; align-items: center; justify-content: center; z-index: 1000; opacity: 0; pointer-events: none; transition: opacity 0.3s ease;
        }
        .modal-overlay.active { opacity: 1; pointer-events: all; }
        .modal {
            width: 90%; max-width: 700px; max-height: 85vh; background: linear-gradient(135deg, var(--sand) 0%, var(--brown-light) 100%);
            border: 6px solid var(--brown-dark); border-radius: 12px; padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8), inset 0 4px 0 rgba(255, 255, 255, 0.3);
            transform: scale(0.8) translateY(50px); transition: transform 0.4s ease; overflow-y: auto; position: relative;
        }
        .modal-overlay.active .modal { transform: scale(1) translateY(0); }
        .modal-header {
            font-family: 'Press Start 2P', cursive; font-size: 14px; text-align: center; margin-bottom: 20px; color: var(--brown-dark);
            text-transform: uppercase; letter-spacing: 2px; padding-bottom: 10px; text-shadow: 2px 2px 0 rgba(255, 255, 255, 0.5);
        }
        .close-modal {
            position: absolute; top: 14px; right: 14px; background: var(--red); border: 3px solid var(--brown-dark); color: var(--cream);
            width: 44px; height: 44px; border-radius: 6px; cursor: pointer; font-size: 20px; display: flex; align-items: center; justify-content: center;
            transition: all 0.2s ease; box-shadow: 0 4px 0 var(--brown-dark); z-index: 10;
        }
        .close-modal:hover { transform: translateY(-2px); box-shadow: 0 6px 0 var(--brown-dark); }
        .close-modal:active { transform: translateY(2px); box-shadow: 0 2px 0 var(--brown-dark); }
        .skill-tree-scroll { 
            max-height: calc(100vh - 200px); 
            height: 600px;
            overflow-y: auto; 
            overflow-x: hidden;
            padding: 10px; 
        }
        .skill-tree-container {
            position: relative; min-height: 700px; padding: 10px; width: 100%; display: flex; justify-content: center;
        }
        .skill-tree-inner { position: relative; width: 650px; height: 700px; }
        .skill-node {
            position: absolute; width: 45px; height: 55px; background: linear-gradient(135deg, var(--sand), var(--brown-light));
            border: 2px solid var(--brown-dark); border-radius: 6px; cursor: pointer; 
            transition: all 0.3s ease, transform 0.2s ease;
            display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 4px;
        }
        .skill-node.bought { background: linear-gradient(135deg, #b8d48e, #7ba05b); border-color: #ffd700; box-shadow: 0 0 10px rgba(255,215,0,0.6); }
        .skill-node.locked { opacity: 0.4; cursor: not-allowed; }
        .skill-node.can-buy:hover { transform: scale(1.1); box-shadow: 0 0 15px rgba(255,215,0,0.4); }
        .skill-icon-sm { font-size: 16px; margin-bottom: 2px; }
        .skill-name-sm { font-family: 'Press Start 2P'; font-size: 5px; text-align: center; line-height: 1.1; margin-bottom: 2px; max-width: 40px; }
        .skill-cost-sm { font-size: 6px; color: var(--gold); font-weight: bold; }
        .skill-line {
            position: absolute; background: var(--brown-med); z-index: 0; transition: all 0.3s ease;
        }
        .skill-line.active { background: linear-gradient(180deg, #7ba05b, #b8d48e); box-shadow: 0 0 8px rgba(123, 160, 91, 0.5); }
        
        .skill-detail-modal { width: 90%; max-width: 500px; }
        .skill-detail-content { text-align: center; padding: 20px; }
        .skill-detail-icon { font-size: 64px; margin-bottom: 15px; }
        .skill-detail-name { font-family: 'Press Start 2P'; font-size: 14px; margin-bottom: 15px; color: var(--brown-dark); }
        .skill-detail-desc { font-size: 14px; margin-bottom: 20px; line-height: 1.8; color: var(--brown-med); font-weight: 600; }
        .skill-detail-cost { font-size: 16px; color: var(--gold); margin-bottom: 15px; font-weight: bold; }
        .skill-detail-requires { font-size: 12px; color: var(--red); margin-bottom: 20px; font-weight: 600; }
        .skill-action-btns { display: flex; gap: 12px; justify-content: center; }
        .skill-buy-btn {
            font-family: 'Press Start 2P'; background: var(--green-med); border: 3px solid var(--brown-dark);
            color: var(--cream); padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 10px;
            box-shadow: 0 4px 0 var(--brown-dark); transition: all 0.2s;
        }
        .skill-buy-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 0 var(--brown-dark); }
        .skill-buy-btn:active { transform: translateY(2px); box-shadow: 0 2px 0 var(--brown-dark); }
        .skill-buy-btn.disabled { opacity: 0.5; cursor: not-allowed; }
        
        .tutorial-content { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 14px; margin-top: 16px; }
        .tutorial-section { background: rgba(255, 255, 255, 0.2); border: 3px solid var(--brown-dark); border-radius: 8px; padding: 12px; }
        .tutorial-title { font-family: 'Press Start 2P', cursive; font-size: 10px; color: var(--brown-dark); margin-bottom: 10px; display: flex; align-items: center; gap: 6px; }
        .tutorial-text { font-size: 12px; color: var(--brown-med); line-height: 1.7; font-weight: 600; }
        .achievement-grid, .stats-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr)); gap: 10px; margin-top: 16px; max-height: 60vh; overflow-y: auto; padding: 5px; }
        .achievement-card {
            background: rgba(255,255,255,0.3); border: 3px solid var(--brown-dark); border-radius: 8px; padding: 10px;
            transition: all 0.3s; cursor: default;
        }
        .achievement-card.done { background: linear-gradient(135deg, #ffd700, #f4a261); box-shadow: 0 0 20px rgba(255,215,0,0.6); }
        .achievement-card.locked { opacity: 0.5; }
        .toast {
            font-family: 'Press Start 2P', cursive; position: fixed; bottom: 140px; left: 20px;
            background: linear-gradient(135deg, var(--brown-light), var(--brown-med)); color: var(--cream); padding: 8px 14px; border-radius: 6px; font-size: 7px;
            box-shadow: 0 4px 0 var(--brown-dark); animation: toast-slide-left 0.4s ease, toast-out-left 0.4s ease 2.6s forwards; z-index: 3000;
            border: 2px solid var(--brown-dark); text-shadow: 1px 1px 0 var(--brown-dark); line-height: 1.4; max-width: 250px;
        }
        @keyframes toast-slide-left { from { opacity: 0; transform: translateX(-100px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes toast-out-left { to { opacity: 0; transform: translateX(-100px); } }
        
        /* Camera Recenter Button */
        .recenter-btn {
            position: fixed; bottom: 90px; left: 20px; width: 45px; height: 45px;
            background: linear-gradient(135deg, var(--orange), var(--red));
            border: 3px solid var(--brown-dark); border-radius: 50%;
            cursor: pointer; transition: all 0.2s ease;
            display: flex; align-items: center; justify-content: center;
            box-shadow: 0 3px 0 var(--brown-dark), 0 5px 12px rgba(0,0,0,0.4);
            z-index: 150; font-size: 22px;
        }
        .recenter-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 5px 0 var(--brown-dark), 0 8px 16px rgba(0,0,0,0.5);
        }
        .recenter-btn:active {
            transform: translateY(1px);
            box-shadow: 0 2px 0 var(--brown-dark), 0 3px 8px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="hud">
            <div class="hud-left">
                <div class="stat-row"><span class="stat-icon">‚ù§Ô∏è</span><div class="bar-container"><div class="bar-fill hp-bar" id="hp-bar" style="width: 100%"></div><div class="bar-text" id="hp-text">100/100</div></div></div>
                <div class="stat-row"><span class="stat-icon">‚ú®</span><div class="bar-container"><div class="bar-fill xp-bar" id="xp-bar" style="width: 0%"></div><div class="bar-text" id="xp-text">0/100</div></div></div>
            </div>
            <div class="hud-center"><div class="wizard-level" id="level-display">LVL 1</div><div class="resource-display"><span class="resource-icon">‚ö°ü™Ñ</span><span id="essence-display">0</span><span style="font-size: 9px; margin-left: 3px;">SP</span></div></div>
            <div class="hud-right">
                <div class="stat-row">
                    <span class="stat-icon" id="day-night-icon">‚òÄÔ∏è</span>
                    <span id="day-night-text" style="font-size: 8px; color: var(--cream); text-shadow: 1px 1px 0 var(--brown-dark);">Day</span>
                    <span class="stat-icon" id="weather-icon" style="font-size: 20px; margin-left: 8px;">‚òÅÔ∏è</span>
                </div>
                <div class="menu-buttons">
                    <button class="menu-btn" onclick="game.openModal('tutorial')">‚ùì</button>
                    <button class="menu-btn" onclick="game.openModal('achievements')">üèÜ</button>
                    <button class="menu-btn" onclick="game.openModal('stats')">üìä</button>
                    <button class="menu-btn" onclick="game.toggleFullscreen()">‚õ∂</button>
                </div>
            </div>
        </div>
        <div class="version-text" style="position: fixed; top: 5px; right: 10px; font-family: 'Press Start 2P'; font-size: 5px; color: rgba(255,255,255,0.4); text-shadow: 1px 1px 0 rgba(0,0,0,0.5); z-index: 100;">castervalleyupdate1.0</div>
        <div id="game-world"><canvas id="game-canvas"></canvas></div>
        <div id="toolbar"></div>
        
        <!-- Left Side Area Tabs -->
        <div class="left-tabs">
            <div class="left-tab" id="farm-tab" onclick="game.switchArea('farm')" title="Farm">
                <div class="left-tab-icon">üåæ</div>
                <div class="left-tab-label">FARM</div>
            </div>
            <div class="left-tab" id="forest-tab" onclick="game.switchArea('forest')" title="Forest">
                <div class="left-tab-icon">üå≤</div>
                <div class="left-tab-label">FOREST</div>
            </div>
            <div class="left-tab" id="mine-tab" onclick="game.switchArea('mine')" title="Mine">
                <div class="left-tab-icon">‚õèÔ∏è</div>
                <div class="left-tab-label">MINE</div>
            </div>
            <div class="left-tab" id="fishing-tab" onclick="game.switchArea('fishing')" title="Fishing">
                <div class="left-tab-icon">üé£</div>
                <div class="left-tab-label">FISHING</div>
            </div>
            <div class="left-tab locked" id="astral-tab" onclick="game.switchArea('astral')" title="Astral Realm" style="display: none;">
                <div class="left-tab-icon">ü™ê</div>
                <div class="left-tab-label">ASTRAL</div>
            </div>
        </div>
        
        <!-- Camera Recenter Button -->
        <button class="recenter-btn" onclick="game.recenterCamera()" title="Recenter Camera">üéØ</button>
        
        <!-- Expandable Shop Tab -->
        <div class="side-tab" id="shop-tab" onclick="game.toggleTab('shop')">
            <div class="tab-close" onclick="event.stopPropagation(); game.closeTab('shop')">‚úï</div>
            <div class="tab-icon-text">
                <div class="tab-icon">üè™</div>
                <div class="tab-label">SHOP</div>
            </div>
            <div class="tab-content-wrapper">
                <div class="tab-header">üè™ SHOP</div>
                <div id="shop-content"></div>
            </div>
        </div>
        
        <!-- Expandable Skills Tab -->
        <div class="side-tab" id="skills-tab" onclick="game.toggleTab('skills')">
            <div class="tab-close" onclick="event.stopPropagation(); game.closeTab('skills')">‚úï</div>
            <div class="tab-icon-text">
                <div class="tab-icon">üåü</div>
                <div class="tab-label">SKILLS</div>
            </div>
            <div class="tab-content-wrapper">
                <div class="tab-header">üåü SKILLS</div>
                <div id="skills-tab-content"></div>
            </div>
        </div>
        
        
        <div class="modal-overlay" id="tutorial-modal" onclick="game.handleModalClick(event, 'tutorial')">
            <div class="modal" onclick="event.stopPropagation()">
                <button class="close-modal" onclick="game.closeModal('tutorial')">‚úï</button>
                <div class="modal-header">üìñ How to Play</div>
                <div class="tutorial-content">
                    <div class="tutorial-section">
                        <div class="tutorial-title">üå± Farming</div>
                        <div class="tutorial-text">‚Ä¢ Drag seeds to plots<br>‚Ä¢ Tap glowing plants<br>‚Ä¢ Get SP + seeds!</div>
                    </div>
                    <div class="tutorial-section">
                        <div class="tutorial-title">‚õèÔ∏è Mine (150 SP)</div>
                        <div class="tutorial-text">‚Ä¢ Tap rocks<br>‚Ä¢ Quick SP</div>
                    </div>
                    <div class="tutorial-section">
                        <div class="tutorial-title">‚öîÔ∏è Forest (800 SP)</div>
                        <div class="tutorial-text">‚Ä¢ Fight trolls<br>‚Ä¢ Big rewards<br>‚Ä¢ <strong>Feed fish to dragon!</strong></div>
                    </div>
                    <div class="tutorial-section">
                        <div class="tutorial-title">üé£ Fishing (2200 SP)</div>
                        <div class="tutorial-text">‚Ä¢ Tap swimming fish<br>‚Ä¢ Collect fish inventory<br>‚Ä¢ Feed to dragon in forest!</div>
                    </div>
                    <div class="tutorial-section">
                        <div class="tutorial-title">ü™ê Astral</div>
                        <div class="tutorial-text">‚Ä¢ Complete achievements<br>‚Ä¢ Burst Saturns<br>‚Ä¢ Space rewards!</div>
                    </div>
                    <div class="tutorial-section">
                        <div class="tutorial-title">üè™ Store</div>
                        <div class="tutorial-text">‚Ä¢ Sell unwanted seeds<br>‚Ä¢ Sell extra fish<br>‚Ä¢ Get SP + XP!</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="modal-overlay" id="skills-modal" onclick="game.handleModalClick(event, 'skills')">
            <div class="modal" onclick="event.stopPropagation()">
                <button class="close-modal" onclick="game.closeModal('skills')">‚úï</button>
                <div class="modal-header">üåü Skill Tree</div>
                <div class="skill-tree-scroll">
                    <div id="skill-tree" class="skill-tree-container"></div>
                </div>
            </div>
        </div>

        <div class="modal-overlay" id="skill-detail-modal" onclick="game.handleModalClick(event, 'skill-detail')">
            <div class="modal skill-detail-modal" onclick="event.stopPropagation()">
                <button class="close-modal" onclick="game.closeModal('skill-detail')">‚úï</button>
                <div id="skill-detail-content" class="skill-detail-content"></div>
            </div>
        </div>
        
        <div class="modal-overlay" id="achievements-modal" onclick="game.handleModalClick(event, 'achievements')">
            <div class="modal" onclick="event.stopPropagation()">
                <button class="close-modal" onclick="game.closeModal('achievements')">‚úï</button>
                <div class="modal-header">üèÜ Achievements</div>
                <div id="achievement-grid" class="achievement-grid"></div>
            </div>
        </div>
        
        <div class="modal-overlay" id="stats-modal" onclick="game.handleModalClick(event, 'stats')">
            <div class="modal" onclick="event.stopPropagation()">
                <button class="close-modal" onclick="game.closeModal('stats')">‚úï</button>
                <div class="modal-header">üìä Statistics</div>
                <div id="stats-grid" class="stats-grid"></div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const SAVE_VERSION = 2;
        const SEED_TIERS = [
            { tier: 1, icon: 'üå±', color: 0xc9562c, sp: 3, sellPrice: 2, name: 'Embersprout' },
            { tier: 2, icon: 'üå∫', color: 0xf4a261, sp: 8, sellPrice: 5, name: 'Sunpetal' },
            { tier: 3, icon: 'üçÉ', color: 0xe9c46a, sp: 18, sellPrice: 12, name: 'Goldleaf' },
            { tier: 4, icon: 'ü™∑', color: 0xb8d48e, sp: 35, sellPrice: 25, name: 'Lotus Dream' },
            { tier: 5, icon: 'üåπ', color: 0x7ba05b, sp: 65, sellPrice: 50, name: 'Thornvine' },
            { tier: 6, icon: '‚ö°', color: 0x6ba3d0, sp: 110, sellPrice: 85, name: 'Stormbloom' },
            { tier: 7, icon: 'üîÆ', color: 0x87ceeb, sp: 180, sellPrice: 140, name: 'Crystalroot' },
            { tier: 8, icon: 'üíú', color: 0x9d84b7, sp: 280, sellPrice: 220, name: 'Voidflower' },
            { tier: 9, icon: 'üå∏', color: 0xd0c4e3, sp: 450, sellPrice: 360, name: 'Moonblossom' },
            { tier: 10, icon: '‚ú®', color: 0xffd700, sp: 700, sellPrice: 550, name: 'Stardust' },
        ];
        
        const SKILLS = [
            // Column 1 - GROWTH (left side, x: 40)
            { id: 'growth1', name: 'Growth I', desc: 'Plants grow 20% faster. Essential for early game farming efficiency.', cost: 80, stat: 'plantSpeed', value: 0.2, icon: 'üå±', x: 40, y: 60 },
            { id: 'growth2', name: 'Growth II', desc: 'Plants grow 40% faster total. Significantly speeds up crop cycles.', cost: 250, stat: 'plantSpeed', value: 0.2, icon: 'üåø', x: 40, y: 125, requires: ['growth1'] },
            { id: 'growth3', name: 'Growth III', desc: 'Plants grow 70% faster total. Massive productivity boost!', cost: 700, stat: 'plantSpeed', value: 0.3, icon: 'üå≥', x: 40, y: 190, requires: ['growth2'] },
            { id: 'growth4', name: 'Growth IV', desc: 'Plants grow 110% faster total. Double speed farming!', cost: 2000, stat: 'plantSpeed', value: 0.4, icon: 'üå≤', x: 40, y: 255, requires: ['growth3'] },
            { id: 'growth5', name: 'Growth V', desc: 'Plants grow 160% faster total. Ultimate farming speed!', cost: 5000, stat: 'plantSpeed', value: 0.5, icon: 'üéã', x: 40, y: 320, requires: ['growth4'] },
            
            // Column 2 - BOUNTY (x: 110)
            { id: 'bounty1', name: 'Bounty I', desc: 'Gain 25% more SP from all sources. Your first multiplier!', cost: 120, stat: 'essenceMult', value: 0.25, icon: 'üíé', x: 110, y: 60 },
            { id: 'bounty2', name: 'Bounty II', desc: 'Gain 50% more SP total. Major income boost!', cost: 350, stat: 'essenceMult', value: 0.25, icon: 'üíé', x: 110, y: 125, requires: ['bounty1'] },
            { id: 'bounty3', name: 'Bounty III', desc: 'Gain 80% more SP total. Wealth accelerator!', cost: 900, stat: 'essenceMult', value: 0.3, icon: 'üí∞', x: 110, y: 190, requires: ['bounty2'] },
            { id: 'bounty4', name: 'Bounty IV', desc: 'Gain 120% more SP total. Elite earnings!', cost: 2500, stat: 'essenceMult', value: 0.4, icon: 'üí∞', x: 110, y: 255, requires: ['bounty3'] },
            { id: 'bounty5', name: 'Bounty V', desc: 'Gain 170% more SP total. Maximum profit!', cost: 6000, stat: 'essenceMult', value: 0.5, icon: 'üí∞', x: 110, y: 320, requires: ['bounty4'] },
            
            // Column 3 - UTILITY (center, x: 180)
            { id: 'regen1', name: 'Regen I', desc: 'Restore 5 HP every 5 seconds. Never die again!', cost: 300, stat: 'hpRegen', value: 5, icon: 'üíö', x: 180, y: 90, requires: ['bounty1'] },
            { id: 'regen2', name: 'Regen II', desc: 'Restore 12 HP every 5 seconds. Fast healing!', cost: 1300, stat: 'hpRegen', value: 7, icon: 'üíö', x: 180, y: 155, requires: ['regen1'] },
            { id: 'plots1', name: 'Plots I', desc: 'Unlock +4 farm plots. More planting space!', cost: 450, stat: 'extraPlots', value: 4, icon: 'üè°', x: 180, y: 220, requires: ['growth2'] },
            { id: 'plots2', name: 'Plots II', desc: 'Unlock +4 more farm plots. Massive farm!', cost: 2000, stat: 'extraPlots', value: 4, icon: 'üè°', x: 180, y: 285, requires: ['plots1'] },
            { id: 'fisher', name: 'Fisher', desc: 'Gain 50% more SP from fishing. Oceanborn!', cost: 2800, stat: 'fishLuck', value: 0.5, icon: 'üé£', x: 180, y: 350, requires: ['bounty3'] },
            
            // Column 4 - POWER (x: 250)
            { id: 'power1', name: 'Power I', desc: 'Deal +20 damage to enemies. Start hitting harder!', cost: 180, stat: 'baseDamage', value: 20, icon: '‚ö°', x: 250, y: 60 },
            { id: 'power2', name: 'Power II', desc: 'Deal +50 damage total. Solid combat upgrade!', cost: 550, stat: 'baseDamage', value: 30, icon: '‚ö°', x: 250, y: 125, requires: ['power1'] },
            { id: 'power3', name: 'Power III', desc: 'Deal +90 damage total. Devastating strikes!', cost: 1500, stat: 'baseDamage', value: 40, icon: '‚öîÔ∏è', x: 250, y: 190, requires: ['power2'] },
            { id: 'power4', name: 'Power IV', desc: 'Deal +140 damage total. Crush your foes!', cost: 3500, stat: 'baseDamage', value: 50, icon: '‚öîÔ∏è', x: 250, y: 255, requires: ['power3'] },
            { id: 'power5', name: 'Power V', desc: 'Deal +200 damage total. Ultimate warrior!', cost: 7500, stat: 'baseDamage', value: 60, icon: '‚öîÔ∏è', x: 250, y: 320, requires: ['power4'] },
            
            // Column 5 - HP (right side, x: 320)
            { id: 'hp1', name: 'Vitality I', desc: 'Gain +50 maximum HP. Survive longer in combat!', cost: 100, stat: 'maxHP', value: 50, icon: '‚ù§Ô∏è', x: 320, y: 60 },
            { id: 'hp2', name: 'Vitality II', desc: 'Gain +100 max HP total. Much tankier!', cost: 300, stat: 'maxHP', value: 50, icon: 'üíó', x: 320, y: 125, requires: ['hp1'] },
            { id: 'hp3', name: 'Vitality III', desc: 'Gain +200 max HP total. Serious durability!', cost: 900, stat: 'maxHP', value: 100, icon: 'üíì', x: 320, y: 190, requires: ['hp2'] },
            { id: 'hp4', name: 'Vitality IV', desc: 'Gain +350 max HP total. Nearly unkillable!', cost: 2500, stat: 'maxHP', value: 150, icon: 'üíù', x: 320, y: 255, requires: ['hp3'] },
            { id: 'hp5', name: 'Vitality V', desc: 'Gain +500 max HP total. Legendary toughness!', cost: 6000, stat: 'maxHP', value: 150, icon: 'üíñ', x: 320, y: 320, requires: ['hp4'] },
            
            // Ultimate at top center
            { id: 'master', name: 'Mastery', desc: 'Ultimate power! +100% to ALL stats. Requires all tier 5 skills.', cost: 30000, stat: 'all', value: 1, icon: '‚≠ê', x: 180, y: 20, requires: ['growth5', 'bounty5', 'power5', 'hp5'] },
        ];
        
        const ACHIEVEMENTS = [
            { id: 'first_harvest', name: 'First Steps', desc: 'Harvest your first plant', icon: 'üå±', reward: 20, check: g => g.stats.totalHarvests >= 1 },
            { id: 'budding_farmer', name: 'Budding Farmer', desc: 'Harvest 10 plants', icon: 'üåæ', reward: 60, check: g => g.stats.totalHarvests >= 10 },
            { id: 'skilled_farmer', name: 'Skilled Farmer', desc: 'Harvest 30 plants', icon: 'üåø', reward: 140, check: g => g.stats.totalHarvests >= 30 },
            { id: 'master_farmer', name: 'Master Farmer', desc: 'Harvest 80 plants', icon: 'üå≥', reward: 300, check: g => g.stats.totalHarvests >= 80 },
            { id: 'harvest_legend', name: 'Harvest Legend', desc: 'Harvest 200 plants', icon: 'üëë', reward: 1200, check: g => g.stats.totalHarvests >= 200 },
            { id: 'first_ore', name: 'First Strike', desc: 'Mine 5 rocks', icon: '‚õèÔ∏è', reward: 80, check: g => g.stats.totalRocksMined >= 5 },
            { id: 'dedicated_miner', name: 'Dedicated Miner', desc: 'Mine 20 rocks', icon: 'üíé', reward: 220, check: g => g.stats.totalRocksMined >= 20 },
            { id: 'mining_expert', name: 'Mining Expert', desc: 'Mine 75 rocks', icon: 'üíç', reward: 800, check: g => g.stats.totalRocksMined >= 75 },
            { id: 'troll_slayer', name: 'Troll Slayer', desc: 'Defeat 5 trolls', icon: '‚öîÔ∏è', reward: 160, check: g => g.stats.totalTrollsKilled >= 5 },
            { id: 'troll_hunter', name: 'Troll Hunter', desc: 'Defeat 15 trolls', icon: 'üó°Ô∏è', reward: 420, check: g => g.stats.totalTrollsKilled >= 15 },
            { id: 'troll_bane', name: 'Troll Bane', desc: 'Defeat 50 trolls', icon: 'üèπ', reward: 1800, check: g => g.stats.totalTrollsKilled >= 50 },
            { id: 'first_catch', name: 'First Catch', desc: 'Catch 10 fish', icon: 'üé£', reward: 300, check: g => g.stats.fishCaught >= 10 },
            { id: 'skilled_angler', name: 'Skilled Angler', desc: 'Catch 50 fish', icon: 'üêü', reward: 900, check: g => g.stats.fishCaught >= 50 },
            { id: 'fishing_legend', name: 'Fishing Legend', desc: 'Catch 200 fish', icon: 'üêã', reward: 3500, check: g => g.stats.fishCaught >= 200 },
            { id: 'dragon_friend', name: 'Dragon Friend', desc: 'Feed the dragon 5 fish', icon: 'üêâ', reward: 400, check: g => g.stats.fishFedToDragon >= 5 },
            { id: 'dragon_master', name: 'Dragon Master', desc: 'Feed the dragon 20 fish', icon: 'üêâ', reward: 2000, check: g => g.stats.fishFedToDragon >= 20 },
            { id: 'apprentice', name: 'Apprentice', desc: 'Reach level 5', icon: 'üßô‚Äç‚ôÇÔ∏è', reward: 120, check: g => g.level >= 5 },
            { id: 'skilled_wizard', name: 'Skilled Wizard', desc: 'Reach level 12', icon: 'üßô', reward: 500, check: g => g.level >= 12 },
            { id: 'archmage', name: 'Archmage', desc: 'Reach level 25', icon: 'üîÆ', reward: 2500, check: g => g.level >= 25 },
            { id: 'sp_collector', name: 'SP Collector', desc: 'Earn 5,000 total SP', icon: 'üí∞', reward: 450, check: g => g.stats.totalEssenceEarned >= 5000 },
            { id: 'sp_hoarder', name: 'SP Hoarder', desc: 'Earn 25,000 total SP', icon: 'üíé', reward: 2000, check: g => g.stats.totalEssenceEarned >= 25000 },
            { id: 'sp_emperor', name: 'SP Emperor', desc: 'Earn 100,000 total SP', icon: 'üëë', reward: 8000, check: g => g.stats.totalEssenceEarned >= 100000 },
            { id: 'true_master', name: 'True Master', desc: 'Purchase Arcane Mastery', icon: '‚≠ê', reward: 10000, check: g => g.purchasedSkills.includes('master') },
        ];

        const game = {
            deviceId: null,
            cloudSaveTimer: null,
            essence: 0, hp: 100, maxHP: 100, level: 1, xp: 0, xpNeeded: 100,
            plantSpeed: 0, baseDamage: 0, hpRegen: 0, essenceMult: 0, extraPlots: 0, fishLuck: 0,
            currentArea: 'farm', isDayTime: true, purchasedSkills: [], fishInventory: 0,
            seeds: { 1: 5 }, unlockedAreas: { farm: true, mine: false, forest: false, fishing: false, astral: false },
            farmPlots: [], mineRocks: [], forestTrolls: [], fishingFish: [], astralSaturns: [], dragon: null, farmTractor: null,
            areaObjects: [], // Track all area-specific objects for cleanup
            selectedSeed: null, draggedSeed: null, ghostElement: null, isDragging: false,
            scene: null, camera: null, renderer: null, raycaster: null, mouse: null, wizard: null,
            wizardTarget: { x: -6, z: 0 }, wizardMoving: false,
            stats: { totalHarvests: 0, totalRocksMined: 0, totalTrollsKilled: 0, fishCaught: 0, totalEssenceEarned: 0, deathCount: 0, playtime: 0, saturnsBurst: 0, fishFedToDragon: 0 },
            completedAchievements: [], shownFirstFishNotif: false,
            weather: 'clear', weatherParticles: [], lastSave: Date.now(),
            // Camera control variables
            cameraTarget: { x: 0, y: 0, z: 0 },
            cameraOffset: { x: 0, y: 28, z: 15 },
            defaultCameraOffset: { x: 0, y: 28, z: 15 },
            isDraggingCamera: false,
            previousPointerPosition: { x: 0, y: 0 },
            panSpeed: 0.035,
            maxPanX: 25,
            maxPanZ: 25,
            isRecentering: false,
            zoom: 1.0,
            minZoom: 0.5,
            maxZoom: 2.0,
            touchDistance: 0,

            init() {
                this.deviceId = this.getOrCreateDeviceId();
                const localSavedAt = this.loadGame();
                this.loadCloudSave(localSavedAt);
                
                // Ensure player always starts with seeds if they have none
                if (Object.keys(this.seeds).length === 0 || !this.seeds[1]) {
                    this.seeds = { 1: 5 };
                }
                
                this.setupThreeJS();
                document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
                this.createWorld();
                this.createWizard();
                this.renderToolbar();
                this.renderStore();
                this.setupEventListeners();
                this.updateUI();
                this.animate();
                this.updateWeather();
                
                setInterval(() => this.tick(), 100);
                setInterval(() => { if (this.hpRegen > 0 && this.hp < this.maxHP) { this.hp = Math.min(this.maxHP, this.hp + this.hpRegen); this.updateUI(); } }, 5000);
                setInterval(() => this.stats.playtime++, 1000);
                setInterval(() => { this.isDayTime = !this.isDayTime; this.updateUI(); this.updateDayNightVisuals(); }, 60000); // Day/night every 60 seconds
                setInterval(() => { this.changeWeather(); }, 120000); // Weather every 2 minutes
                setInterval(() => this.saveGame(), 10000);
                
                console.log('üéÆ Caster Valley ready!');
            },

            saveGame() {
                try {
                    const saveData = {
                        essence: this.essence, hp: this.hp, maxHP: this.maxHP, level: this.level, xp: this.xp, xpNeeded: this.xpNeeded,
                        plantSpeed: this.plantSpeed, baseDamage: this.baseDamage, hpRegen: this.hpRegen, essenceMult: this.essenceMult,
                        extraPlots: this.extraPlots, fishLuck: this.fishLuck, currentArea: this.currentArea, isDayTime: this.isDayTime,
                        purchasedSkills: this.purchasedSkills, seeds: this.seeds, unlockedAreas: this.unlockedAreas,
                        stats: this.stats, completedAchievements: this.completedAchievements, fishInventory: this.fishInventory,
                        shownFirstFishNotif: this.shownFirstFishNotif, version: SAVE_VERSION, savedAt: Date.now()
                    };
                    localStorage.setItem('casterValleySave', JSON.stringify(saveData));
                    this.lastSave = Date.now();
                    this.queueCloudSave(saveData);
                } catch (e) {
                    console.error('Save failed:', e);
                }
            },

            loadGame() {
                try {
                    const saved = localStorage.getItem('casterValleySave');
                    if (saved) {
                        const d = JSON.parse(saved);
                        this.applySaveData(d);
                        console.log('‚úÖ Game loaded!');
                        return d.savedAt || 0;
                    }
                } catch (e) {
                    console.error('Load failed:', e);
                }
                return 0;
            },

            applySaveData(d) {
                this.essence = d.essence || 0; this.hp = d.hp || 100; this.maxHP = d.maxHP || 100;
                this.level = d.level || 1; this.xp = d.xp || 0; this.xpNeeded = d.xpNeeded || 100;
                this.plantSpeed = d.plantSpeed || 0; this.baseDamage = d.baseDamage || 0;
                this.hpRegen = d.hpRegen || 0; this.essenceMult = d.essenceMult || 0;
                this.extraPlots = d.extraPlots || 0; this.fishLuck = d.fishLuck || 0;
                this.currentArea = d.currentArea || 'farm'; this.isDayTime = d.isDayTime !== undefined ? d.isDayTime : true;
                this.purchasedSkills = d.purchasedSkills || [];
                this.seeds = d.seeds || { 1: 5 };
                if (!this.seeds[1] || this.seeds[1] <= 0) this.seeds[1] = 5;
                this.unlockedAreas = d.unlockedAreas || { farm: true, mine: false, forest: false, fishing: false, astral: false };
                this.stats = d.stats || { totalHarvests: 0, totalRocksMined: 0, totalTrollsKilled: 0, fishCaught: 0, totalEssenceEarned: 0, deathCount: 0, playtime: 0, saturnsBurst: 0, fishFedToDragon: 0 };
                this.completedAchievements = d.completedAchievements || [];
                this.fishInventory = d.fishInventory || 0;
                this.shownFirstFishNotif = d.shownFirstFishNotif || false;
            },

            getOrCreateDeviceId() {
                try {
                    const key = 'casterValleyDeviceId';
                    const existing = localStorage.getItem(key);
                    if (existing) return existing;
                    const id = (crypto && crypto.randomUUID) ? crypto.randomUUID() : 'cv-' + Math.random().toString(36).slice(2) + Date.now().toString(36);
                    localStorage.setItem(key, id);
                    return id;
                } catch (_) {
                    return 'cv-' + Math.random().toString(36).slice(2) + Date.now().toString(36);
                }
            },

            async loadCloudSave(localSavedAt = 0) {
                try {
                    if (!this.deviceId) return;
                    const resp = await fetch(`/api/caster-valley-save?deviceId=${encodeURIComponent(this.deviceId)}`);
                    if (!resp.ok) return;
                    const data = await resp.json();
                    const cloud = data?.save;
                    if (!cloud || !cloud.savedAt) return;
                    if (cloud.savedAt > (localSavedAt || 0)) {
                        this.applySaveData(cloud);
                        localStorage.setItem('casterValleySave', JSON.stringify(cloud));
                        this.lastSave = Date.now();
                        this.updateUI();
                        this.renderToolbar();
                        this.renderStore();
                    }
                } catch (e) {
                    console.warn('Cloud load failed:', e.message);
                }
            },

            queueCloudSave(saveData) {
                try {
                    if (!this.deviceId || !navigator.onLine) return;
                    if (this.cloudSaveTimer) clearTimeout(this.cloudSaveTimer);
                    this.cloudSaveTimer = setTimeout(async () => {
                        try {
                            await fetch('/api/caster-valley-save', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ deviceId: this.deviceId, save: saveData })
                            });
                        } catch (e) {
                            console.warn('Cloud save failed:', e.message);
                        }
                    }, 1500);
                } catch (_) {}
            },

            updateDayNightVisuals() {
                if (this.isDayTime) {
                    document.body.classList.remove('night-mode');
                    const targetColor = this.currentArea === 'astral' ? 0x0a0a2e : this.currentArea === 'mine' ? 0x2c2c2c : this.currentArea === 'forest' ? 0x2d5016 : this.currentArea === 'fishing' ? 0x87cefd : 0x87ceeb;
                    // Smooth color transition
                    const currentColor = this.scene.background;
                    const target = new THREE.Color(targetColor);
                    currentColor.lerp(target, 0.05);
                } else {
                    document.body.classList.add('night-mode');
                    const nightColors = { farm: 0x2a4a6b, mine: 0x1a1a1a, forest: 0x1a2810, fishing: 0x2a4a6b, astral: 0x0a0a2e };
                    const targetColor = nightColors[this.currentArea] || 0x2a4a6b;
                    // Smooth color transition
                    const currentColor = this.scene.background;
                    const target = new THREE.Color(targetColor);
                    currentColor.lerp(target, 0.05);
                }
            },

            changeWeather() {
                const weathers = ['clear', 'clear', 'rain', 'snow'];
                const newWeather = weathers[Math.floor(Math.random() * weathers.length)];
                if (newWeather !== this.weather) {
                    this.weather = newWeather;
                    this.updateWeather();
                    this.showWeatherNotification();
                }
            },

            showWeatherNotification() {
                const messages = {
                    clear: '‚òÅÔ∏è Clear Weather\nNormal farming speed',
                    rain: 'üåßÔ∏è Rain!\n+25% plant growth speed',
                    snow: '‚ùÑÔ∏è Snow!\n-15% plant growth speed'
                };
                const notif = document.createElement('div');
                notif.className = 'weather-notification';
                notif.innerHTML = `<div class="weather-notification-title">${messages[this.weather].split('\n')[0]}</div><div class="weather-notification-text">${messages[this.weather].split('\n')[1]}</div>`;
                document.body.appendChild(notif);
                setTimeout(() => notif.remove(), 4000);
            },

            updateWeather() {
                this.weatherParticles.forEach(p => this.scene.remove(p));
                this.weatherParticles = [];
                
                const weatherIcons = { clear: '‚òÅÔ∏è', rain: 'üåßÔ∏è', snow: '‚ùÑÔ∏è' };
                document.getElementById('weather-icon').textContent = weatherIcons[this.weather];
                
                if (this.weather === 'rain' && this.currentArea !== 'astral') {
                    const rainGeo = new THREE.BufferGeometry();
                    const rainCount = 500;
                    const positions = new Float32Array(rainCount * 3);
                    for (let i = 0; i < rainCount; i++) {
                        positions[i * 3] = (Math.random() - 0.5) * 50;
                        positions[i * 3 + 1] = Math.random() * 30 + 10;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
                    }
                    rainGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    const rain = new THREE.Points(rainGeo, new THREE.PointsMaterial({ color: 0x87ceeb, size: 0.1, transparent: true, opacity: 0.6 }));
                    this.scene.add(rain);
                    this.weatherParticles.push(rain);
                } else if (this.weather === 'snow' && this.currentArea !== 'astral') {
                    const snowGeo = new THREE.BufferGeometry();
                    const snowCount = 300;
                    const positions = new Float32Array(snowCount * 3);
                    for (let i = 0; i < snowCount; i++) {
                        positions[i * 3] = (Math.random() - 0.5) * 50;
                        positions[i * 3 + 1] = Math.random() * 30 + 10;
                        positions[i * 3 + 2] = (Math.random() - 0.5) * 50;
                    }
                    snowGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    const snow = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.8 }));
                    this.scene.add(snow);
                    this.weatherParticles.push(snow);
                }
            },

            getDifficultyMultiplier() {
                return 1 + (this.level - 1) * 0.1;
            },

            setupThreeJS() {
                const canvas = document.getElementById('game-canvas');
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x87ceeb);
                
                this.camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 100);
                // Camera starts at default offset from target
                this.camera.position.set(
                    this.cameraTarget.x + this.cameraOffset.x,
                    this.cameraTarget.y + this.cameraOffset.y,
                    this.cameraTarget.z + this.cameraOffset.z
                );
                this.camera.lookAt(this.cameraTarget.x, this.cameraTarget.y, this.cameraTarget.z);
                
                this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
                this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.setClearColor(0x000000, 0); // Transparent clear color
                
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const sunLight = new THREE.DirectionalLight(0xffd700, 0.8);
                sunLight.position.set(10, 20, 10);
                sunLight.castShadow = true;
                this.scene.add(sunLight);
                
                // Base ground - will be updated per area
                const groundGeo = new THREE.PlaneGeometry(100, 100);
                const groundMat = new THREE.MeshLambertMaterial({ color: 0x7ba05b });
                this.ground = new THREE.Mesh(groundGeo, groundMat);
                this.ground.rotation.x = -Math.PI / 2;
                this.ground.receiveShadow = true;
                this.scene.add(this.ground);
                
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                window.addEventListener('resize', () => {
                    this.camera.aspect = canvas.clientWidth / canvas.clientHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                });
                document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
                
                // Camera pan event listeners
                this.setupCameraControls();
            },
            
            setupCameraControls() {
                const canvas = document.getElementById('game-canvas');
                
                // Mouse events for desktop
                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) { // Left click only
                        this.isDraggingCamera = true;
                        this.previousPointerPosition = { x: e.clientX, y: e.clientY };
                    }
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (this.isDraggingCamera) {
                        const deltaX = e.clientX - this.previousPointerPosition.x;
                        const deltaY = e.clientY - this.previousPointerPosition.y;
                        
                        // Intuitive map-style dragging - map follows your cursor
                        // Drag right = camera target moves right (see more to the right)
                        // Drag down = camera target moves down (see more below)
                        this.cameraTarget.x += deltaX * this.panSpeed;
                        this.cameraTarget.z += deltaY * this.panSpeed;
                        
                        // Clamp camera position
                        this.cameraTarget.x = Math.max(-this.maxPanX, Math.min(this.maxPanX, this.cameraTarget.x));
                        this.cameraTarget.z = Math.max(-this.maxPanZ, Math.min(this.maxPanZ, this.cameraTarget.z));
                        
                        this.previousPointerPosition = { x: e.clientX, y: e.clientY };
                    }
                });
                
                canvas.addEventListener('mouseup', () => {
                    this.isDraggingCamera = false;
                });
                
                canvas.addEventListener('mouseleave', () => {
                    this.isDraggingCamera = false;
                });
                
                // Touch events for mobile
                canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 1) {
                        this.isDraggingCamera = true;
                        this.previousPointerPosition = {
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY
                        };
                    }
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    if (this.isDraggingCamera && e.touches.length === 1) {
                        const deltaX = e.touches[0].clientX - this.previousPointerPosition.x;
                        const deltaY = e.touches[0].clientY - this.previousPointerPosition.y;
                        
                        // Intuitive map-style dragging - map follows your finger
                        this.cameraTarget.x += deltaX * this.panSpeed;
                        this.cameraTarget.z += deltaY * this.panSpeed;
                        
                        // Clamp camera position
                        this.cameraTarget.x = Math.max(-this.maxPanX, Math.min(this.maxPanX, this.cameraTarget.x));
                        this.cameraTarget.z = Math.max(-this.maxPanZ, Math.min(this.maxPanZ, this.cameraTarget.z));
                        
                        this.previousPointerPosition = {
                            x: e.touches[0].clientX,
                            y: e.touches[0].clientY
                        };
                    }
                });
                
                canvas.addEventListener('touchend', () => {
                    this.isDraggingCamera = false;
                });
                
                // Scroll wheel zoom for desktop
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 0.001;
                    this.zoom -= e.deltaY * zoomSpeed;
                    this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom));
                }, { passive: false });
                
                // Pinch zoom for mobile
                canvas.addEventListener('touchmove', (e) => {
                    if (e.touches.length === 2) {
                        e.preventDefault();
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const currentDistance = Math.sqrt(
                            Math.pow(touch2.clientX - touch1.clientX, 2) +
                            Math.pow(touch2.clientY - touch1.clientY, 2)
                        );
                        
                        if (this.touchDistance > 0) {
                            const delta = currentDistance - this.touchDistance;
                            const zoomSpeed = 0.01;
                            this.zoom += delta * zoomSpeed;
                            this.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom));
                        }
                        
                        this.touchDistance = currentDistance;
                    }
                }, { passive: false });
                
                canvas.addEventListener('touchstart', (e) => {
                    if (e.touches.length === 2) {
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        this.touchDistance = Math.sqrt(
                            Math.pow(touch2.clientX - touch1.clientX, 2) +
                            Math.pow(touch2.clientY - touch1.clientY, 2)
                        );
                    }
                });
                
                canvas.addEventListener('touchend', () => {
                    this.touchDistance = 0;
                });
            },
            
            recenterCamera() {
                this.isRecentering = true;
                // Smooth transition back to default
                const duration = 1000; // 1 second
                const startTime = Date.now();
                const startTarget = { ...this.cameraTarget };
                const startZoom = this.zoom;
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const eased = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                    
                    this.cameraTarget.x = startTarget.x + (0 - startTarget.x) * eased;
                    this.cameraTarget.z = startTarget.z + (0 - startTarget.z) * eased;
                    this.zoom = startZoom + (1.0 - startZoom) * eased;
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        this.isRecentering = false;
                    }
                };
                
                animate();
            },
            
            updateCamera() {
                // Smooth camera follow with lerp, applying zoom
                const zoomedOffsetX = this.cameraOffset.x / this.zoom;
                const zoomedOffsetY = this.cameraOffset.y / this.zoom;
                const zoomedOffsetZ = this.cameraOffset.z / this.zoom;
                
                const targetX = this.cameraTarget.x + zoomedOffsetX;
                const targetY = this.cameraTarget.y + zoomedOffsetY;
                const targetZ = this.cameraTarget.z + zoomedOffsetZ;
                
                this.camera.position.x += (targetX - this.camera.position.x) * 0.15;
                this.camera.position.y += (targetY - this.camera.position.y) * 0.15;
                this.camera.position.z += (targetZ - this.camera.position.z) * 0.15;
                
                this.camera.lookAt(this.cameraTarget.x, this.cameraTarget.y, this.cameraTarget.z);
            },

            clearAreaObjects() {
                // Remove all area-specific objects
                this.areaObjects.forEach(obj => {
                    if (obj.parent) this.scene.remove(obj);
                });
                this.areaObjects = [];
                
                // Clear arrays
                this.farmPlots = [];
                this.mineRocks = [];
                this.forestTrolls = [];
                this.fishingFish = [];
                this.astralSaturns = [];
                this.ratThieves = []; // Rats that steal crops
                this.dragon = null;
            },

            createWorld() {
                this.clearAreaObjects();
                
                if (this.currentArea === 'farm') {
                    this.createFarm();
                } else if (this.currentArea === 'mine') {
                    this.createMine();
                } else if (this.currentArea === 'forest') {
                    this.createForest();
                } else if (this.currentArea === 'fishing') {
                    this.createFishing();
                } else if (this.currentArea === 'astral') {
                    this.createAstral();
                }
                
                this.updateDayNightVisuals();
                this.updateWeather();
            },

            createFarm() {
                this.scene.background = new THREE.Color(0x87ceeb);
                
                // Reset ground to solid grass
                this.ground.material.color.setHex(0x7ba05b);
                this.ground.material.transparent = false;
                this.ground.material.opacity = 1.0;
                
                // Add grass texture with patches of different greens - AVOID CENTER
                for (let i = 0; i < 150; i++) {
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * 60;
                        z = (Math.random() - 0.5) * 60;
                    } while (Math.abs(x) < 18 && Math.abs(z) < 18); // Skip center plot area
                    
                    const grassPatch = new THREE.Mesh(
                        new THREE.CircleGeometry(0.8 + Math.random() * 0.5, 8),
                        new THREE.MeshLambertMaterial({ 
                            color: [0x6d9450, 0x7ba05b, 0x8fb570][Math.floor(Math.random() * 3)],
                            transparent: true,
                            opacity: 0.4
                        })
                    );
                    grassPatch.position.set(
                        x,
                        0.01 + i * 0.0001, // Vary y position to prevent z-fighting
                        z
                    );
                    grassPatch.rotation.x = -Math.PI / 2;
                    this.scene.add(grassPatch);
                    this.areaObjects.push(grassPatch);
                }
                
                // Add grass blades texture effect - AVOID CENTER
                for (let i = 0; i < 200; i++) {
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * 60;
                        z = (Math.random() - 0.5) * 60;
                    } while (Math.abs(x) < 18 && Math.abs(z) < 18); // Skip center plot area
                    
                    const grass = new THREE.Mesh(
                        new THREE.ConeGeometry(0.05, 0.15, 3),
                        new THREE.MeshLambertMaterial({ color: 0x5a7647 })
                    );
                    grass.position.set(x, 0.08, z);
                    grass.rotation.x = -Math.PI / 2 + (Math.random() - 0.5) * 0.3;
                    this.scene.add(grass);
                    this.areaObjects.push(grass);
                }
                
                // Farm plots (spread wider)
                const total = 12 + this.extraPlots;
                for (let i = 0; i < total; i++) {
                    const col = i % 4;
                    const row = Math.floor(i / 4);
                    const x = (col - 1.5) * 4.2; // Wider spacing
                    const z = (row - Math.floor(total / 4) / 2) * 4.2; // Wider spacing
                    
                    const plot = new THREE.Mesh(new THREE.BoxGeometry(2, 0.3, 2), new THREE.MeshLambertMaterial({ color: 0x6d5633 }));
                    plot.position.set(x, 0.15, z);
                    plot.castShadow = true;
                    plot.receiveShadow = true;
                    this.scene.add(plot);
                    this.areaObjects.push(plot);
                    
                    this.farmPlots.push({ mesh: plot, x, z, seed: null, growthTime: 0, growthNeeded: 15000, plantMesh: null });
                }
                
                // Red barn with roof (moved further out)
                const barn = new THREE.Mesh(new THREE.BoxGeometry(3, 2.5, 2.5), new THREE.MeshLambertMaterial({ color: 0x8b0000 }));
                barn.position.set(15, 1.25, -12); // Moved from (9, 1.25, -9)
                barn.castShadow = true;
                this.scene.add(barn);
                this.areaObjects.push(barn);
                
                const barnRoof = new THREE.Mesh(new THREE.ConeGeometry(2.2, 1.5, 4), new THREE.MeshLambertMaterial({ color: 0x6d0000 }));
                barnRoof.position.set(15, 3.25, -12); // Moved to match barn
                barnRoof.rotation.y = Math.PI / 4;
                barnRoof.castShadow = true;
                this.scene.add(barnRoof);
                this.areaObjects.push(barnRoof);
                
                // Green tractor (starts at left, will drive around)
                const tractorBody = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 1.8), new THREE.MeshLambertMaterial({ color: 0x2e7d32 }));
                tractorBody.position.set(-14, 0.4, 10);
                tractorBody.castShadow = true;
                this.scene.add(tractorBody);
                this.areaObjects.push(tractorBody);
                
                const tractorCab = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.8), new THREE.MeshLambertMaterial({ color: 0x1b5e20 }));
                tractorCab.position.set(-14, 0.9, 10.3);
                tractorCab.castShadow = true;
                this.scene.add(tractorCab);
                this.areaObjects.push(tractorCab);
                
                // Tractor wheels
                const wheelGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.2, 16);
                const wheelMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
                const wheels = [];
                [[0.7, 0.3, 0.6], [-0.7, 0.3, 0.6], [0.7, 0.3, -0.6], [-0.7, 0.3, -0.6]].forEach(([ox, oy, oz]) => {
                    const wheel = new THREE.Mesh(wheelGeo, wheelMat);
                    wheel.position.set(-14 + ox, oy, 10 + oz);
                    wheel.rotation.z = Math.PI / 2;
                    this.scene.add(wheel);
                    this.areaObjects.push(wheel);
                    wheels.push({ mesh: wheel, offsetX: ox, offsetZ: oz });
                });
                
                // Store tractor for animation
                this.farmTractor = {
                    body: tractorBody,
                    cab: tractorCab,
                    wheels: wheels,
                    time: 0,
                    path: 'circle' // Drives in circle
                };
                
                // Add 25 decorative trees scattered across ENTIRE map
                for (let i = 0; i < 25; i++) {
                    const x = (Math.random() - 0.5) * 60; // -30 to 30
                    const z = (Math.random() - 0.5) * 60; // -30 to 30
                    
                    // Skip if too close to center farm plots
                    if (Math.sqrt(x * x + z * z) < 8) continue;
                    
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.4, 3 + Math.random(), 8),
                        new THREE.MeshLambertMaterial({ color: 0x4a2511 })
                    );
                    trunk.position.set(x, 1.5, z);
                    trunk.castShadow = true;
                    this.scene.add(trunk);
                    this.areaObjects.push(trunk);
                    
                    // Tree leaves
                    const leaves = new THREE.Mesh(
                        new THREE.SphereGeometry(1.5 + Math.random() * 0.5, 8, 8),
                        new THREE.MeshLambertMaterial({ color: 0x2d5016 })
                    );
                    leaves.position.set(x, 3.5, z);
                    leaves.scale.set(1, 0.8, 1);
                    this.scene.add(leaves);
                    this.areaObjects.push(leaves);
                }
                
                // Add flower patches - MUCH FURTHER from center, prefer edges (150 flowers)
                for (let i = 0; i < 150; i++) {
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * 60;
                        z = (Math.random() - 0.5) * 60;
                    } while (Math.abs(x) < 18 && Math.abs(z) < 18); // Bigger avoid zone
                    
                    const flower = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 6, 6),
                        new THREE.MeshLambertMaterial({ 
                            color: [0xff6b6b, 0xffd93d, 0xffffff, 0xff69b4, 0x9d84b7][Math.floor(Math.random() * 5)],
                            emissive: [0xff6b6b, 0xffd93d, 0xffffff, 0xff69b4, 0x9d84b7][Math.floor(Math.random() * 5)],
                            emissiveIntensity: 0.3
                        })
                    );
                    flower.position.set(x, 0.15, z);
                    this.scene.add(flower);
                    this.areaObjects.push(flower);
                }
                
                // Add rocks - MUCH FURTHER from center (60 rocks)
                for (let i = 0; i < 60; i++) {
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * 60;
                        z = (Math.random() - 0.5) * 60;
                    } while (Math.abs(x) < 18 && Math.abs(z) < 18); // Bigger avoid zone
                    
                    const rock = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(0.3 + Math.random() * 0.3, 0),
                        new THREE.MeshLambertMaterial({ color: 0x808080 })
                    );
                    rock.position.set(x, 0.2, z);
                    rock.rotation.set(Math.random(), Math.random(), Math.random());
                    this.scene.add(rock);
                    this.areaObjects.push(rock);
                }
                
                // Add bushes - MUCH FURTHER from center (80 bushes)
                for (let i = 0; i < 80; i++) {
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * 60;
                        z = (Math.random() - 0.5) * 60;
                    } while (Math.abs(x) < 18 && Math.abs(z) < 18); // Bigger avoid zone
                    
                    const bush = new THREE.Mesh(
                        new THREE.SphereGeometry(0.5 + Math.random() * 0.3, 8, 8),
                        new THREE.MeshLambertMaterial({ color: 0x2d5016 })
                    );
                    bush.position.set(x, 0.3, z);
                    bush.scale.set(1, 0.6, 1);
                    this.scene.add(bush);
                    this.areaObjects.push(bush);
                }
                
                // Golden hay bales (spread wider)
                const hayGeo = new THREE.CylinderGeometry(0.6, 0.6, 0.8, 16);
                const hayMat = new THREE.MeshLambertMaterial({ color: 0xdaa520 });
                [[12, 10], [-12, -10], [10, -12], [-11, 8], [9, 13], [-13, -11]].forEach(([x, z]) => { // Spread wider
                    const hay = new THREE.Mesh(hayGeo, hayMat);
                    hay.rotation.z = Math.PI / 2;
                    hay.position.set(x, 0.4, z);
                    hay.castShadow = true;
                    this.scene.add(hay);
                    this.areaObjects.push(hay);
                });
                
                // Circular fence with horizontal rails (larger radius)
                // REMOVED - looked too organized
                
                // Natural fence posts scattered around perimeter (not circular!)
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2 + (Math.random() - 0.5) * 0.8;
                    const distance = 24 + Math.random() * 6;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    const post = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.12, 0.12, 1.5 + Math.random() * 0.5, 8),
                        new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                    );
                    post.position.set(x, 0.75, z);
                    post.rotation.z = (Math.random() - 0.5) * 0.2; // Slight tilt
                    post.castShadow = true;
                    this.scene.add(post);
                    this.areaObjects.push(post);
                }
                
                // Windmill (moved further away)
                const windmillBase = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.7, 4, 8), new THREE.MeshLambertMaterial({ color: 0xd3d3d3 }));
                windmillBase.position.set(-15, 2, -15); // Moved from (-10, 2, -10)
                windmillBase.castShadow = true;
                this.scene.add(windmillBase);
                this.areaObjects.push(windmillBase);
                
                const windmillTop = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1, 8), new THREE.MeshLambertMaterial({ color: 0xc9562c }));
                windmillTop.position.set(-15, 4.5, -15); // Moved to match base
                windmillTop.castShadow = true;
                this.scene.add(windmillTop);
                this.areaObjects.push(windmillTop);
                
                // Dirt paths around farm plots
                const pathPositions = [
                    // Horizontal paths
                    { x: 0, z: 7, w: 16, h: 1.5 },
                    { x: 0, z: -7, w: 16, h: 1.5 },
                    // Vertical paths  
                    { x: 7, z: 0, w: 1.5, h: 16 },
                    { x: -7, z: 0, w: 1.5, h: 16 },
                ];
                pathPositions.forEach(p => {
                    const path = new THREE.Mesh(
                        new THREE.PlaneGeometry(p.w, p.h),
                        new THREE.MeshLambertMaterial({ color: 0x8b7355, transparent: true, opacity: 0.6 })
                    );
                    path.position.set(p.x, 0.03, p.z);
                    path.rotation.x = -Math.PI / 2;
                    this.scene.add(path);
                    this.areaObjects.push(path);
                });
                
                // Small fence sections in corners
                const cornerFencePositions = [
                    [8, 8], [-8, 8], [8, -8], [-8, -8]
                ];
                cornerFencePositions.forEach(([x, z]) => {
                    // Vertical post
                    const post = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 1.2, 0.15),
                        new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                    );
                    post.position.set(x, 0.6, z);
                    post.castShadow = true;
                    this.scene.add(post);
                    this.areaObjects.push(post);
                    
                    // Horizontal rail
                    const rail = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.1, 0.1),
                        new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                    );
                    rail.position.set(x, 0.7, z);
                    this.scene.add(rail);
                    this.areaObjects.push(rail);
                });
                
                // Grass tufts between plots
                for (let i = 0; i < 40; i++) {
                    const tuft = new THREE.Mesh(
                        new THREE.ConeGeometry(0.15, 0.3, 6),
                        new THREE.MeshLambertMaterial({ color: 0x5a7647 })
                    );
                    tuft.position.set(
                        (Math.random() - 0.5) * 12,
                        0.15,
                        (Math.random() - 0.5) * 12
                    );
                    tuft.rotation.x = (Math.random() - 0.5) * 0.4;
                    this.scene.add(tuft);
                    this.areaObjects.push(tuft);
                }
                
                // Farm tools scattered around
                // Hoe
                const hoeHandle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.04, 0.04, 1.4, 8),
                    new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                );
                hoeHandle.position.set(10, 0.3, 8);
                hoeHandle.rotation.z = Math.PI / 3;
                this.scene.add(hoeHandle);
                this.areaObjects.push(hoeHandle);
                
                const hoeBlade = new THREE.Mesh(
                    new THREE.BoxGeometry(0.5, 0.08, 0.08),
                    new THREE.MeshLambertMaterial({ color: 0x888888 })
                );
                hoeBlade.position.set(10.6, 0.8, 8);
                this.scene.add(hoeBlade);
                this.areaObjects.push(hoeBlade);
                
                // Rake
                const rakeHandle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.04, 0.04, 1.3, 8),
                    new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                );
                rakeHandle.position.set(-10, 0.3, -8);
                rakeHandle.rotation.z = -Math.PI / 4;
                this.scene.add(rakeHandle);
                this.areaObjects.push(rakeHandle);
                
                // Watering can
                const canBody = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.35, 0.5, 8),
                    new THREE.MeshLambertMaterial({ color: 0x4a90e2 })
                );
                canBody.position.set(9, 0.25, -9);
                this.scene.add(canBody);
                this.areaObjects.push(canBody);
                
                const canSpout = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8),
                    new THREE.MeshLambertMaterial({ color: 0x4a90e2 })
                );
                canSpout.position.set(9.3, 0.35, -9);
                canSpout.rotation.z = Math.PI / 4;
                this.scene.add(canSpout);
                this.areaObjects.push(canSpout);
            },

            createMine() {
                this.scene.background = new THREE.Color(0x2c2c2c);
                const diffMult = this.getDifficultyMultiplier();
                
                // Brown dirt ground
                this.ground.material.color.setHex(0x6d4c2f);
                this.ground.material.transparent = false;
                this.ground.material.opacity = 1.0;
                
                // Rocky dirt patches for texture
                for (let i = 0; i < 40; i++) {
                    const patchSize = 1.5 + Math.random() * 2;
                    const patch = new THREE.Mesh(
                        new THREE.CircleGeometry(patchSize, 8),
                        new THREE.MeshLambertMaterial({ 
                            color: [0x5a3d2f, 0x4a2d1f, 0x6d4c2f][Math.floor(Math.random() * 3)],
                            transparent: true,
                            opacity: 0.6
                        })
                    );
                    patch.position.set(
                        (Math.random() - 0.5) * 40,
                        0.02,
                        (Math.random() - 0.5) * 40
                    );
                    patch.rotation.x = -Math.PI / 2;
                    this.scene.add(patch);
                    this.areaObjects.push(patch);
                }
                
                // Small pebbles scattered
                for (let i = 0; i < 60; i++) {
                    const pebble = new THREE.Mesh(
                        new THREE.CircleGeometry(0.1 + Math.random() * 0.2, 6),
                        new THREE.MeshLambertMaterial({ color: 0x808080, transparent: true, opacity: 0.7 })
                    );
                    pebble.position.set(
                        (Math.random() - 0.5) * 38,
                        0.02,
                        (Math.random() - 0.5) * 38
                    );
                    pebble.rotation.x = -Math.PI / 2;
                    this.scene.add(pebble);
                    this.areaObjects.push(pebble);
                }
                
                // Create CONNECTED cave walls that actually form a cave
                const wallMat = new THREE.MeshLambertMaterial({ color: 0x4a4a4a, emissive: 0x2a2a2a, emissiveIntensity: 0.1 });
                
                // Create continuous wall ring with 30 segments
                for (let i = 0; i < 30; i++) {
                    const angle = (i / 30) * Math.PI * 2;
                    const nextAngle = ((i + 1) / 30) * Math.PI * 2;
                    
                    // Vary distance for organic feel
                    const distance = 36 + Math.sin(i * 0.5) * 5 + (Math.random() - 0.5) * 2;
                    const nextDistance = 36 + Math.sin((i + 1) * 0.5) * 5 + (Math.random() - 0.5) * 2;
                    
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    const nextX = Math.cos(nextAngle) * nextDistance;
                    const nextZ = Math.sin(nextAngle) * nextDistance;
                    
                    // Calculate wall width to connect to next segment
                    const width = Math.sqrt((nextX - x) ** 2 + (nextZ - z) ** 2) + 1;
                    const height = 8 + Math.random() * 4;
                    
                    const wall = new THREE.Mesh(
                        new THREE.BoxGeometry(width, height, 3 + Math.random()),
                        wallMat
                    );
                    
                    // Position between current and next point
                    wall.position.set(
                        (x + nextX) / 2,
                        height / 2,
                        (z + nextZ) / 2
                    );
                    
                    // Rotate to face outward
                    wall.rotation.y = angle + Math.PI / 2;
                    wall.castShadow = true;
                    this.scene.add(wall);
                    this.areaObjects.push(wall);
                    
                    // Add rocky protrusions for texture
                    for (let j = 0; j < 2; j++) {
                        const rock = new THREE.Mesh(
                            new THREE.DodecahedronGeometry(0.5 + Math.random() * 0.4, 0),
                            new THREE.MeshLambertMaterial({ color: 0x666666 })
                        );
                        rock.position.set(
                            wall.position.x + (Math.random() - 0.5) * 2,
                            wall.position.y + (Math.random() - 0.5) * height * 0.5,
                            wall.position.z + (Math.random() - 0.5) * 2
                        );
                        rock.rotation.set(Math.random(), Math.random(), Math.random());
                        this.scene.add(rock);
                        this.areaObjects.push(rock);
                    }
                }
                
                // Water stream flowing through cave
                for (let i = 0; i < 28; i++) {
                    const streamSegment = new THREE.Mesh(
                        new THREE.PlaneGeometry(2.5, 3),
                        new THREE.MeshPhongMaterial({ 
                            color: 0x4a90e2,
                            shininess: 80,
                            specular: 0x9fd5ff,
                            transparent: true,
                            opacity: 0.7
                        })
                    );
                    streamSegment.position.set(
                        -18 + i * 1.6,
                        0.05,
                        -12 + Math.sin(i * 0.4) * 4
                    );
                    streamSegment.rotation.x = -Math.PI / 2;
                    this.scene.add(streamSegment);
                    this.areaObjects.push(streamSegment);
                }
                
                // 60 Stalactites hanging from ceiling across ENTIRE cave floor
                const stalactiteGeo = new THREE.ConeGeometry(0.3, 2, 8);
                const stalactiteMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
                for (let i = 0; i < 60; i++) {
                    const stalactite = new THREE.Mesh(stalactiteGeo, stalactiteMat);
                    stalactite.position.set(
                        (Math.random() - 0.5) * 80,
                        9 + Math.random() * 2,
                        (Math.random() - 0.5) * 80
                    );
                    stalactite.rotation.x = Math.PI;
                    stalactite.scale.set(1, 0.8 + Math.random() * 0.6, 1);
                    this.scene.add(stalactite);
                    this.areaObjects.push(stalactite);
                }
                
                // 50 Stalagmites rising from ground across ENTIRE cave floor
                const stalagmiteGeo = new THREE.ConeGeometry(0.35, 2.5, 8);
                const stalagmiteMat = new THREE.MeshLambertMaterial({ color: 0x757575 });
                for (let i = 0; i < 50; i++) {
                    const stalagmite = new THREE.Mesh(stalagmiteGeo, stalagmiteMat);
                    stalagmite.position.set(
                        (Math.random() - 0.5) * 80,
                        1.25,
                        (Math.random() - 0.5) * 80
                    );
                    stalagmite.scale.set(1, 0.7 + Math.random() * 0.8, 1);
                    stalagmite.castShadow = true;
                    this.scene.add(stalagmite);
                    this.areaObjects.push(stalagmite);
                }
                
                // 15 Column formations spread across ENTIRE mine floor
                for (let i = 0; i < 15; i++) {
                    const x = (Math.random() - 0.5) * 70;
                    const z = (Math.random() - 0.5) * 70;
                    const column = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.45, 10, 8),
                        new THREE.MeshLambertMaterial({ color: 0x6a6a6a })
                    );
                    column.position.set(x, 5, z);
                    column.castShadow = true;
                    this.scene.add(column);
                    this.areaObjects.push(column);
                }
                
                // 20 Mine carts spread randomly across ENTIRE mine
                for (let i = 0; i < 20; i++) {
                    const cartX = (Math.random() - 0.5) * 70;
                    const cartZ = (Math.random() - 0.5) * 70;
                    const cartBody = new THREE.Mesh(
                        new THREE.BoxGeometry(1.2, 0.6, 0.8),
                        new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                    );
                    cartBody.position.set(cartX, 0.3, cartZ);
                    this.scene.add(cartBody);
                    this.areaObjects.push(cartBody);
                    
                    const cartWheelGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 8);
                    const cartWheelMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
                    [[0.5, 0.15, 0.5], [-0.5, 0.15, 0.5], [0.5, 0.15, -0.5], [-0.5, 0.15, -0.5]].forEach(([ox, oy, oz]) => {
                        const wheel = new THREE.Mesh(cartWheelGeo, cartWheelMat);
                        wheel.position.set(cartX + ox, oy, cartZ + oz);
                        wheel.rotation.x = Math.PI / 2;
                        this.scene.add(wheel);
                        this.areaObjects.push(wheel);
                    });
                }
                
                // 35 Pickaxes scattered across ENTIRE mine
                for (let i = 0; i < 35; i++) {
                    const px = (Math.random() - 0.5) * 70;
                    const pz = (Math.random() - 0.5) * 70;
                    const handle = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05, 0.05, 1.2, 8),
                        new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                    );
                    handle.position.set(px, 0.6, pz);
                    handle.rotation.z = Math.PI / 4 + Math.random() * 0.5;
                    this.scene.add(handle);
                    this.areaObjects.push(handle);
                    
                    const head = new THREE.Mesh(
                        new THREE.BoxGeometry(0.6, 0.15, 0.15),
                        new THREE.MeshLambertMaterial({ color: 0x888888 })
                    );
                    head.position.set(px + 0.5, 1.1, pz);
                    this.scene.add(head);
                    this.areaObjects.push(head);
                }
                
                // 40 Glowing lanterns scattered throughout mine
                for (let i = 0; i < 40; i++) {
                    const x = (Math.random() - 0.5) * 70;
                    const z = (Math.random() - 0.5) * 70;
                    const lantern = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.2, 0.3, 0.6, 8),
                        new THREE.MeshLambertMaterial({ 
                            color: 0xffaa00,
                            emissive: 0xffaa00,
                            emissiveIntensity: 0.5
                        })
                    );
                    lantern.position.set(x, 1.5, z);
                    this.scene.add(lantern);
                    this.areaObjects.push(lantern);
                    
                    const light = new THREE.PointLight(0xffaa00, 0.5, 5);
                    light.position.set(x, 1.5, z);
                    this.scene.add(light);
                    this.areaObjects.push(light);
                }
                
                // 50 Boulder piles scattered across mine
                const boulderGeo = new THREE.SphereGeometry(0.8, 8, 8);
                const boulderMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
                for (let i = 0; i < 50; i++) {
                    const x = (Math.random() - 0.5) * 70;
                    const z = (Math.random() - 0.5) * 70;
                    for (let j = 0; j < 2; j++) {
                        const boulder = new THREE.Mesh(boulderGeo, boulderMat);
                        boulder.position.set(x + (Math.random() - 0.5) * 2, 0.4 + j * 0.6, z + (Math.random() - 0.5) * 2);
                        boulder.scale.set(1.2, 0.8, 1);
                        this.scene.add(boulder);
                        this.areaObjects.push(boulder);
                    }
                }
                
                // Mineable rocks with HP bars - spread across ENTIRE mine floor with better spacing
                const rockPositions = [];
                for (let i = 0; i < 18; i++) {
                    // Random position with minimum distance from other rocks
                    let x, z, tooClose;
                    do {
                        x = (Math.random() - 0.5) * 65; // -32.5 to 32.5 (much wider spread)
                        z = (Math.random() - 0.5) * 65; // -32.5 to 32.5
                        
                        // Check distance from existing rocks
                        tooClose = false;
                        for (const pos of rockPositions) {
                            const dist = Math.sqrt((x - pos.x) ** 2 + (z - pos.z) ** 2);
                            if (dist < 10) { // Min 10 units apart for natural spacing
                                tooClose = true;
                                break;
                            }
                        }
                    } while (tooClose);
                    
                    rockPositions.push({ x, z });
                    
                    // Main rock (MUCH BIGGER - dark gray)
                    const rock = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(1.8, 0), // Was 0.8, now 1.8!
                        new THREE.MeshLambertMaterial({ 
                            color: 0x4a4a4a,
                            emissive: 0x2a2a2a,
                            emissiveIntensity: 0.1
                        })
                    );
                    rock.position.set(x, 1.8, z);
                    rock.rotation.set(Math.random(), Math.random(), Math.random());
                    rock.castShadow = true;
                    this.scene.add(rock);
                    this.areaObjects.push(rock);
                    
                    // Add 5-8 BLUE CRYSTAL SHARDS embedded in the rock (not glowing diamonds)
                    const numShards = 5 + Math.floor(Math.random() * 4);
                    for (let j = 0; j < numShards; j++) {
                        const shard = new THREE.Mesh(
                            new THREE.BoxGeometry(0.15, 0.4, 0.08), // Flat crystal shard shape
                            new THREE.MeshLambertMaterial({ 
                                color: 0x4169e1, // Royal blue (not cyan)
                                emissive: 0x4169e1,
                                emissiveIntensity: 0.3, // Subtle glow
                                transparent: true,
                                opacity: 0.8
                            })
                        );
                        // Position shards embedded in rock surface
                        const angle = (j / numShards) * Math.PI * 2 + Math.random();
                        const vertAngle = Math.random() * Math.PI;
                        const surfaceX = x + Math.cos(angle) * Math.sin(vertAngle) * 1.3;
                        const surfaceY = 1.8 + Math.cos(vertAngle) * 1.3;
                        const surfaceZ = z + Math.sin(angle) * Math.sin(vertAngle) * 1.3;
                        
                        shard.position.set(surfaceX, surfaceY, surfaceZ);
                        
                        // Rotate shard to point outward from rock center
                        shard.lookAt(x, 1.8, z);
                        shard.rotateX(Math.PI / 2);
                        shard.rotation.z += (Math.random() - 0.5) * 0.5;
                        
                        this.scene.add(shard);
                        this.areaObjects.push(shard);
                    }
                    
                    const hpBarBg = new THREE.Mesh(new THREE.PlaneGeometry(2.4, 0.25), new THREE.MeshBasicMaterial({ color: 0x333333 }));
                    hpBarBg.position.set(x, 3.8, z);
                    this.scene.add(hpBarBg);
                    this.areaObjects.push(hpBarBg);
                    
                    const hpBarFill = new THREE.Mesh(new THREE.PlaneGeometry(2.4, 0.25), new THREE.MeshBasicMaterial({ color: 0x22c55e }));
                    hpBarFill.position.set(x, 3.8, z + 0.01);
                    this.scene.add(hpBarFill);
                    this.areaObjects.push(hpBarFill);
                    
                    const maxHP = Math.floor(60 * diffMult);
                    this.mineRocks.push({ mesh: rock, x, z, hp: maxHP, maxHP: maxHP, hpBarBg, hpBarFill });
                }
            },

            createForest() {
                this.scene.background = new THREE.Color(0x2d5016);
                const diffMult = this.getDifficultyMultiplier();
                
                // Dark forest ground
                this.ground.material.color.setHex(0x2d5016);
                this.ground.material.transparent = false;
                this.ground.material.opacity = 1.0;
                
                // Mossy patches across ENTIRE map
                for (let i = 0; i < 80; i++) {
                    const patchSize = 2 + Math.random() * 3;
                    const patch = new THREE.Mesh(
                        new THREE.CircleGeometry(patchSize, 12),
                        new THREE.MeshLambertMaterial({ 
                            color: [0x3a6b2d, 0x2d5016, 0x1a3d10][Math.floor(Math.random() * 3)],
                            transparent: true,
                            opacity: 0.5
                        })
                    );
                    patch.position.set(
                        (Math.random() - 0.5) * 60, // Full map coverage
                        0.01 + i * 0.0001, // Prevent z-fighting
                        (Math.random() - 0.5) * 60
                    );
                    patch.rotation.x = -Math.PI / 2;
                    this.scene.add(patch);
                    this.areaObjects.push(patch);
                }
                
                // Scattered leaves across ENTIRE map
                for (let i = 0; i < 150; i++) {
                    const leaf = new THREE.Mesh(
                        new THREE.CircleGeometry(0.15 + Math.random() * 0.1, 5),
                        new THREE.MeshLambertMaterial({ 
                            color: [0x8b4513, 0xa0522d, 0xd2691e][Math.floor(Math.random() * 3)],
                            transparent: true,
                            opacity: 0.7
                        })
                    );
                    leaf.position.set(
                        (Math.random() - 0.5) * 60,
                        0.02 + i * 0.00005,
                        (Math.random() - 0.5) * 60
                    );
                    leaf.rotation.x = -Math.PI / 2;
                    leaf.rotation.z = Math.random() * Math.PI;
                    this.scene.add(leaf);
                    this.areaObjects.push(leaf);
                }
                
                // 50 Large pine trees scattered across FULL map
                const treePositions = []; // Store tree positions for collision detection
                for (let i = 0; i < 50; i++) {
                    // Random position avoiding center area where trolls/dragon are
                    let x, z;
                    do {
                        x = (Math.random() - 0.5) * 60;
                        z = (Math.random() - 0.5) * 60;
                    } while (Math.sqrt(x * x + z * z) < 8); // Keep center clear
                    
                    treePositions.push({ x, z }); // Store position
                    
                    const trunkHeight = 4 + Math.random() * 2;
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.5, trunkHeight, 8),
                        new THREE.MeshLambertMaterial({ color: 0x4a2511 })
                    );
                    trunk.position.set(x, trunkHeight / 2, z);
                    trunk.castShadow = true;
                    this.scene.add(trunk);
                    this.areaObjects.push(trunk);
                    
                    // 3-layer pine leaves
                    for (let j = 0; j < 3; j++) {
                        const leaves = new THREE.Mesh(
                            new THREE.ConeGeometry(2 - j * 0.4, 1.5, 8),
                            new THREE.MeshLambertMaterial({ color: 0x1a5a1a })
                        );
                        leaves.position.set(x, trunkHeight + 0.5 + j * 1, z);
                        leaves.castShadow = true;
                        this.scene.add(leaves);
                        this.areaObjects.push(leaves);
                    }
                }
                this.forestTreePositions = treePositions; // Store for troll spawning
                
                // 100 Green bushes spread across map
                for (let i = 0; i < 100; i++) {
                    const bush = new THREE.Mesh(
                        new THREE.SphereGeometry(0.6 + Math.random() * 0.3, 8, 8),
                        new THREE.MeshLambertMaterial({ color: 0x2d5016 })
                    );
                    bush.position.set(
                        (Math.random() - 0.5) * 60,
                        0.3,
                        (Math.random() - 0.5) * 60
                    );
                    bush.scale.set(1, 0.6, 1);
                    this.scene.add(bush);
                    this.areaObjects.push(bush);
                }
                
                // 15 Fallen logs across map
                const logGeo = new THREE.CylinderGeometry(0.3, 0.3, 3, 8);
                const logMat = new THREE.MeshLambertMaterial({ color: 0x4a2511 });
                for (let i = 0; i < 15; i++) {
                    const log = new THREE.Mesh(logGeo, logMat);
                    log.position.set(
                        (Math.random() - 0.5) * 60,
                        0.3,
                        (Math.random() - 0.5) * 60
                    );
                    log.rotation.z = Math.PI / 2;
                    log.rotation.y = Math.random() * Math.PI;
                    this.scene.add(log);
                    this.areaObjects.push(log);
                }
                
                // 40 Gray rocks scattered across map
                for (let i = 0; i < 40; i++) {
                    const rock = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(0.4 + Math.random() * 0.3, 0),
                        new THREE.MeshLambertMaterial({ color: 0x808080 })
                    );
                    rock.position.set(
                        (Math.random() - 0.5) * 60,
                        0.3,
                        (Math.random() - 0.5) * 60
                    );
                    rock.rotation.set(Math.random(), Math.random(), Math.random());
                    this.scene.add(rock);
                    this.areaObjects.push(rock);
                }
                
                // 30 Mushrooms across forest
                for (let i = 0; i < 30; i++) {
                    const x = (Math.random() - 0.5) * 60;
                    const z = (Math.random() - 0.5) * 60;
                    
                    const stem = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.12, 0.15, 0.35, 8),
                        new THREE.MeshLambertMaterial({ color: 0xf5f5dc })
                    );
                    stem.position.set(x, 0.18, z);
                    this.scene.add(stem);
                    this.areaObjects.push(stem);
                    
                    const cap = new THREE.Mesh(
                        new THREE.SphereGeometry(0.28, 8, 8),
                        new THREE.MeshLambertMaterial({ 
                            color: [0xff0000, 0xff6b6b, 0x8b4513][Math.floor(Math.random() * 3)]
                        })
                    );
                    cap.position.set(x, 0.45, z);
                    cap.scale.set(1, 0.5, 1);
                    this.scene.add(cap);
                    this.areaObjects.push(cap);
                }
                
                // 20 Gray rocks randomly scattered
                const rockGeo = new THREE.DodecahedronGeometry(0.5, 0);
                const rockMat = new THREE.MeshLambertMaterial({ color: 0x808080 });
                for (let i = 0; i < 20; i++) {
                    const rock = new THREE.Mesh(rockGeo, rockMat);
                    rock.position.set(
                        (Math.random() - 0.5) * 40,
                        0.25,
                        (Math.random() - 0.5) * 40
                    );
                    rock.rotation.set(Math.random(), Math.random(), Math.random());
                    rock.scale.set(0.8 + Math.random() * 0.4, 0.8 + Math.random() * 0.4, 0.8 + Math.random() * 0.4);
                    this.scene.add(rock);
                    this.areaObjects.push(rock);
                }
                
                // EPIC MENACING BLUE DRAGON - properly hierarchical so head stays attached
                const dragonGroup = new THREE.Group();
                dragonGroup.position.set(0, 2.2, -8);
                this.scene.add(dragonGroup);
                this.areaObjects.push(dragonGroup);
                
                const dragonBody = new THREE.Mesh(
                    new THREE.CylinderGeometry(2.0, 2.5, 4, 12),
                    new THREE.MeshLambertMaterial({ color: 0x1e90ff, emissive: 0x1e90ff, emissiveIntensity: 0.5 })
                );
                dragonBody.position.set(0, 0, 0);
                dragonBody.castShadow = true;
                dragonGroup.add(dragonBody);
                
                // Scales on body
                for (let i = 0; i < 8; i++) {
                    const scale = new THREE.Mesh(
                        new THREE.ConeGeometry(0.3, 0.4, 4),
                        new THREE.MeshLambertMaterial({ color: 0x0066cc })
                    );
                    const angle = (i / 8) * Math.PI * 2;
                    scale.position.set(
                        Math.cos(angle) * 2.0,
                        0.3 + Math.sin(i * 0.5) * 0.3,
                        Math.sin(angle) * 0.5
                    );
                    scale.rotation.z = angle;
                    dragonGroup.add(scale);
                }
                
                const dragonNeck = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.9, 1.3, 2.5, 10),
                    new THREE.MeshLambertMaterial({ color: 0x1e90ff, emissive: 0x1e90ff, emissiveIntensity: 0.5 })
                );
                dragonNeck.position.set(0, 2.6, 0);
                dragonNeck.rotation.z = 0.2;
                dragonNeck.castShadow = true;
                dragonGroup.add(dragonNeck);
                
                const dragonHead = new THREE.Mesh(
                    new THREE.BoxGeometry(1.6, 1.2, 2.0),
                    new THREE.MeshLambertMaterial({ color: 0x1e90ff, emissive: 0x1e90ff, emissiveIntensity: 0.5 })
                );
                dragonHead.position.set(-0.4, 3.8, 0.5);
                dragonHead.castShadow = true;
                dragonGroup.add(dragonHead);
                
                // Snout (menacing)
                const snout = new THREE.Mesh(
                    new THREE.ConeGeometry(0.6, 1.0, 8),
                    new THREE.MeshLambertMaterial({ color: 0x0066cc })
                );
                snout.position.set(-0.4, 3.8, 1.7);
                snout.rotation.x = Math.PI / 2;
                dragonGroup.add(snout);
                
                const leftEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 12, 12),
                    new THREE.MeshBasicMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1.0 })
                );
                leftEye.position.set(-0.9, 3.9, 0.2);
                dragonGroup.add(leftEye);
                
                const rightEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2, 12, 12),
                    new THREE.MeshBasicMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1.0 })
                );
                rightEye.position.set(0.1, 3.9, 0.2);
                dragonGroup.add(rightEye);
                
                // Sharp horns
                const leftHorn = new THREE.Mesh(
                    new THREE.ConeGeometry(0.2, 1.0, 6),
                    new THREE.MeshLambertMaterial({ color: 0x4169e1 })
                );
                leftHorn.position.set(-1.0, 4.7, -0.3);
                leftHorn.rotation.z = -0.4;
                dragonGroup.add(leftHorn);
                
                const rightHorn = new THREE.Mesh(
                    new THREE.ConeGeometry(0.2, 1.0, 6),
                    new THREE.MeshLambertMaterial({ color: 0x4169e1 })
                );
                rightHorn.position.set(0.2, 4.7, -0.3);
                rightHorn.rotation.z = 0.4;
                dragonGroup.add(rightHorn);
                
                // Large wings
                const leftWing = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 3.5, 2.5),
                    new THREE.MeshLambertMaterial({ color: 0x4db8ff, transparent: true, opacity: 0.85 })
                );
                leftWing.position.set(2.0, 0.8, 0);
                leftWing.rotation.z = 0.6;
                leftWing.rotation.y = -0.3;
                dragonGroup.add(leftWing);
                
                const rightWing = new THREE.Mesh(
                    new THREE.BoxGeometry(0.3, 3.5, 2.5),
                    new THREE.MeshLambertMaterial({ color: 0x4db8ff, transparent: true, opacity: 0.85 })
                );
                rightWing.position.set(-2.0, 0.8, 0);
                rightWing.rotation.z = -0.6;
                rightWing.rotation.y = 0.3;
                dragonGroup.add(rightWing);
                
                // Tail
                const tail = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.8, 3, 8),
                    new THREE.MeshLambertMaterial({ color: 0x1e90ff })
                );
                tail.position.set(0, -1.2, -1.8);
                tail.rotation.x = -0.5;
                dragonGroup.add(tail);
                
                this.dragon = { 
                    group: dragonGroup,
                    body: dragonBody, 
                    neck: dragonNeck, 
                    head: dragonHead,
                    snout,
                    leftEye, 
                    rightEye, 
                    leftHorn, 
                    rightHorn, 
                    leftWing, 
                    rightWing,
                    tail,
                    isFlying: false,
                    flyTime: 0,
                    flyRadius: 16,
                    flyHeight: 10
                };
                
                // Trolls (randomly positioned, avoid dragon AND trees)
                for (let i = 0; i < 5; i++) {
                    // Random position avoiding dragon and trees
                    let x, z, tooCloseToTree;
                    do {
                        x = (Math.random() - 0.5) * 24; // -12 to 12
                        z = Math.random() * 16 + 4; // 4 to 20 (in front of dragon)
                        
                        // Check distance from dragon
                        const dragonDist = Math.sqrt(x * x + (z + 8) * (z + 8));
                        
                        // Check distance from all trees
                        tooCloseToTree = false;
                        if (this.forestTreePositions) {
                            for (const tree of this.forestTreePositions) {
                                const treeDist = Math.sqrt((x - tree.x) ** 2 + (z - tree.z) ** 2);
                                if (treeDist < 3) { // Min 3 units from any tree
                                    tooCloseToTree = true;
                                    break;
                                }
                            }
                        }
                    } while (Math.sqrt(x * x + (z + 8) * (z + 8)) < 6 || tooCloseToTree); // Keep distance from dragon AND trees
                    
                    // Large muscular body (troll-like proportions)
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(1.4, 2.2, 1.0), // Wide, tall, thick
                        new THREE.MeshLambertMaterial({ color: 0x6b8e23, emissive: 0x556b2f, emissiveIntensity: 0.2 })
                    );
                    body.position.set(x, 1.3, z);
                    body.castShadow = true;
                    this.scene.add(body);
                    this.areaObjects.push(body);
                    
                    // Big ugly head
                    const head = new THREE.Mesh(
                        new THREE.BoxGeometry(0.9, 0.9, 0.8),
                        new THREE.MeshLambertMaterial({ color: 0x6b8e23, emissive: 0x556b2f, emissiveIntensity: 0.2 })
                    );
                    head.position.set(x, 2.7, z);
                    head.castShadow = true;
                    this.scene.add(head);
                    this.areaObjects.push(head);
                    
                    // Big nose
                    const nose = new THREE.Mesh(
                        new THREE.ConeGeometry(0.2, 0.4, 8),
                        new THREE.MeshLambertMaterial({ color: 0x556b2f })
                    );
                    nose.position.set(x, 2.7, z + 0.5);
                    nose.rotation.x = Math.PI / 2;
                    this.scene.add(nose);
                    this.areaObjects.push(nose);
                    
                    // Angry red eyes
                    const leftEye = new THREE.Mesh(
                        new THREE.SphereGeometry(0.12, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000 })
                    );
                    leftEye.position.set(x - 0.2, 2.8, z + 0.35);
                    this.scene.add(leftEye);
                    this.areaObjects.push(leftEye);
                    
                    const rightEye = new THREE.Mesh(
                        new THREE.SphereGeometry(0.12, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000 })
                    );
                    rightEye.position.set(x + 0.2, 2.8, z + 0.35);
                    this.scene.add(rightEye);
                    this.areaObjects.push(rightEye);
                    
                    // Left arm (muscular)
                    const leftArm = new THREE.Mesh(
                        new THREE.BoxGeometry(0.4, 1.6, 0.4),
                        new THREE.MeshLambertMaterial({ color: 0x6b8e23 })
                    );
                    leftArm.position.set(x - 0.9, 1.3, z);
                    leftArm.rotation.z = 0.3;
                    this.scene.add(leftArm);
                    this.areaObjects.push(leftArm);
                    
                    // Right arm (muscular)
                    const rightArm = new THREE.Mesh(
                        new THREE.BoxGeometry(0.4, 1.6, 0.4),
                        new THREE.MeshLambertMaterial({ color: 0x6b8e23 })
                    );
                    rightArm.position.set(x + 0.9, 1.3, z);
                    rightArm.rotation.z = -0.3;
                    this.scene.add(rightArm);
                    this.areaObjects.push(rightArm);
                    
                    // Left leg
                    const leftLeg = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 1.2, 0.5),
                        new THREE.MeshLambertMaterial({ color: 0x8b7355 })
                    );
                    leftLeg.position.set(x - 0.4, 0.6, z);
                    this.scene.add(leftLeg);
                    this.areaObjects.push(leftLeg);
                    
                    // Right leg
                    const rightLeg = new THREE.Mesh(
                        new THREE.BoxGeometry(0.5, 1.2, 0.5),
                        new THREE.MeshLambertMaterial({ color: 0x8b7355 })
                    );
                    rightLeg.position.set(x + 0.4, 0.6, z);
                    this.scene.add(rightLeg);
                    this.areaObjects.push(rightLeg);
                    
                    const hpBarBg = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 0.3), new THREE.MeshBasicMaterial({ color: 0x333333 }));
                    hpBarBg.position.set(x, 3.6, z);
                    this.scene.add(hpBarBg);
                    this.areaObjects.push(hpBarBg);
                    
                    const hpBarFill = new THREE.Mesh(new THREE.PlaneGeometry(2.2, 0.3), new THREE.MeshBasicMaterial({ color: 0xef4444 }));
                    hpBarFill.position.set(x, 3.6, z + 0.01);
                    this.scene.add(hpBarFill);
                    this.areaObjects.push(hpBarFill);
                    
                    const maxHP = Math.floor(80 * diffMult);
                    this.forestTrolls.push({ body, head, nose, leftEye, rightEye, leftArm, rightArm, leftLeg, rightLeg, x, z, hp: maxHP, maxHP: maxHP, attackCooldown: 0, hpBarBg, hpBarFill });
                }
            },

            createFishing() {
                this.scene.background = new THREE.Color(0x87cefd);
                
                // Update ground to ocean blue
                this.ground.material.color.setHex(0x1e90ff);
                this.ground.material.transparent = true;
                this.ground.material.opacity = 0.6;
                
                // Add seaweed patches in water (no glitchy circles)
                for (let i = 0; i < 40; i++) {
                    const x = (Math.random() - 0.5) * 16;
                    const z = (Math.random() - 0.5) * 16;
                    const dist = Math.sqrt(x * x + z * z);
                    if (dist < 8) { // Only in water
                        const seaweed = new THREE.Mesh(
                            new THREE.ConeGeometry(0.15, 0.8, 6),
                            new THREE.MeshLambertMaterial({ color: 0x2d5016, emissive: 0x1a3d10, emissiveIntensity: 0.2 })
                        );
                        seaweed.position.set(x, 0.4, z);
                        seaweed.rotation.x = (Math.random() - 0.5) * 0.3;
                        this.scene.add(seaweed);
                        this.areaObjects.push(seaweed);
                    }
                }
                
                // Add small coral formations (no circles!)
                for (let i = 0; i < 25; i++) {
                    const x = (Math.random() - 0.5) * 14;
                    const z = (Math.random() - 0.5) * 14;
                    const dist = Math.sqrt(x * x + z * z);
                    if (dist < 7) {
                        const coral = new THREE.Mesh(
                            new THREE.SphereGeometry(0.2 + Math.random() * 0.15, 6, 6),
                            new THREE.MeshLambertMaterial({ 
                                color: [0xff6b6b, 0xffd93d, 0x9d84b7][Math.floor(Math.random() * 3)],
                                emissive: [0xff6b6b, 0xffd93d, 0x9d84b7][Math.floor(Math.random() * 3)],
                                emissiveIntensity: 0.3
                            })
                        );
                        coral.position.set(x, 0.15, z);
                        this.scene.add(coral);
                        this.areaObjects.push(coral);
                    }
                }
                
                // MUCH BIGGER irregular island (beach) with expanded bounds
                // Main beach circle - EVEN BIGGER
                const beachGeo = new THREE.RingGeometry(14, 40, 64); // Expanded outer radius
                const beachMat = new THREE.MeshLambertMaterial({ color: 0xf4a460 });
                const beach = new THREE.Mesh(beachGeo, beachMat);
                beach.rotation.x = -Math.PI / 2;
                beach.position.y = 0.08;
                this.scene.add(beach);
                this.areaObjects.push(beach);
                
                // SIGNIFICANTLY more sand patches spreading further out
                for (let i = 0; i < 220; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 14 + Math.random() * 32; // Much wider spread (up to 46 units from center)
                    const x = Math.cos(angle) * distance + (Math.random() - 0.5) * 6;
                    const z = Math.sin(angle) * distance + (Math.random() - 0.5) * 6;
                    const sandPatch = new THREE.Mesh(
                        new THREE.CircleGeometry(0.8 + Math.random() * 1.8, 8),
                        new THREE.MeshLambertMaterial({ 
                            color: [0xedd9a8, 0xf4a460, 0xdeb887, 0xf5deb3][Math.floor(Math.random() * 4)],
                            transparent: true,
                            opacity: 0.7
                        })
                    );
                    sandPatch.position.set(x, 0.085 + i * 0.00005, z);
                    sandPatch.rotation.x = -Math.PI / 2;
                    sandPatch.rotation.z = Math.random() * Math.PI;
                    this.scene.add(sandPatch);
                    this.areaObjects.push(sandPatch);
                }
                
                // Add sandy peninsulas extending outward much further for more natural sprawl
                for (let i = 0; i < 8; i++) {
                    const baseAngle = (i / 8) * Math.PI * 2;
                    // Create peninsula extending outward further
                    for (let j = 0; j < 12; j++) {
                        const distance = 20 + j * 2.5; // Extends further out
                        const width = 5 - j * 0.35; // Narrows as it extends
                        const x = Math.cos(baseAngle) * distance + (Math.random() - 0.5) * (width + 1);
                        const z = Math.sin(baseAngle) * distance + (Math.random() - 0.5) * (width + 1);
                        const patch = new THREE.Mesh(
                            new THREE.CircleGeometry(1.2 + Math.random() * 1.2, 8),
                            new THREE.MeshLambertMaterial({ color: 0xf4a460, transparent: true, opacity: 0.8 })
                        );
                        patch.position.set(x, 0.09, z);
                        patch.rotation.x = -Math.PI / 2;
                        this.scene.add(patch);
                        this.areaObjects.push(patch);
                    }
                }
                
                // MANY MORE palm trees spread across much bigger island
                const numPalms = 40 + Math.floor(Math.random() * 12);
                for (let i = 0; i < numPalms; i++) {
                    const angle = (i / numPalms) * Math.PI * 2 + (Math.random() - 0.5) * 1.2;
                    const distance = 17 + Math.random() * 20; // Much wider spread
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    // Brown trunk
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.35, 4, 8),
                        new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                    );
                    trunk.position.set(x, 2, z);
                    trunk.castShadow = true;
                    this.scene.add(trunk);
                    this.areaObjects.push(trunk);
                    
                    // 6 palm leaves
                    for (let j = 0; j < 6; j++) {
                        const leafAngle = (j / 6) * Math.PI * 2;
                        const leaf = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 0.1, 2),
                            new THREE.MeshLambertMaterial({ color: 0x2d5016 })
                        );
                        leaf.position.set(
                            x + Math.cos(leafAngle) * 0.5,
                            4.2,
                            z + Math.sin(leafAngle) * 0.5
                        );
                        leaf.rotation.y = leafAngle;
                        leaf.rotation.z = -0.5;
                        this.scene.add(leaf);
                        this.areaObjects.push(leaf);
                    }
                }
                
                // MANY MORE coconuts scattered across much bigger island
                for (let i = 0; i < 60; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 15 + Math.random() * 24; // Much wider spread
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    const coconut = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3, 8, 8),
                        new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                    );
                    coconut.position.set(x, 0.3, z);
                    this.scene.add(coconut);
                    this.areaObjects.push(coconut);
                }
                
                // MORE beach rocks along shoreline and beach
                for (let i = 0; i < 45; i++) {
                    const angle = (i / 45) * Math.PI * 2;
                    const distance = 14 + Math.random() * 4;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    const rock = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(0.4 + Math.random() * 0.4, 0),
                        new THREE.MeshLambertMaterial({ color: 0x808080 })
                    );
                    rock.position.set(x, 0.3, z);
                    rock.rotation.set(Math.random(), Math.random(), Math.random());
                    this.scene.add(rock);
                    this.areaObjects.push(rock);
                }
                
                // MANY MORE rocks spread across beach and island
                for (let i = 0; i < 70; i++) {
                    let x, z, distFromCenter;
                    do {
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 14 + Math.random() * 24; // Across full island/beach area
                        x = Math.cos(angle) * distance;
                        z = Math.sin(angle) * distance;
                        distFromCenter = Math.sqrt(x * x + z * z);
                    } while (distFromCenter < 14 || distFromCenter > 38); // Spread across wider beach area
                    
                    const rock = new THREE.Mesh(
                        new THREE.DodecahedronGeometry(0.4 + Math.random() * 0.4, 0),
                        new THREE.MeshLambertMaterial({ color: 0x808080 })
                    );
                    rock.position.set(x, 0.2, z);
                    rock.rotation.set(Math.random(), Math.random(), Math.random());
                    this.scene.add(rock);
                    this.areaObjects.push(rock);
                }
                
                // Floating logs across water
                for (let i = 0; i < 15; i++) {
                    const x = (Math.random() - 0.5) * 40;
                    const z = (Math.random() - 0.5) * 40;
                    const log = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.2, 0.2, 2 + Math.random(), 8),
                        new THREE.MeshLambertMaterial({ color: 0x4a2511 })
                    );
                    log.position.set(x, 0.1, z);
                    log.rotation.z = Math.PI / 2;
                    log.rotation.y = Math.random() * Math.PI;
                    this.scene.add(log);
                    this.areaObjects.push(log);
                }
                
                // 30 Seaweed plants
                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 5 + Math.random() * 8;
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    
                    const seaweed = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.05 + Math.random() * 0.05, 0.1, 1.5, 8),
                        new THREE.MeshLambertMaterial({ color: 0x2d5016, transparent: true, opacity: 0.6 })
                    );
                    seaweed.position.set(x, 0.75, z);
                    this.scene.add(seaweed);
                    this.areaObjects.push(seaweed);
                }
                
                // Wooden dock
                const dockBase = new THREE.Mesh(
                    new THREE.BoxGeometry(6, 0.3, 2),
                    new THREE.MeshLambertMaterial({ color: 0x8b4513 })
                );
                dockBase.position.set(0, 0.3, -14);
                this.scene.add(dockBase);
                this.areaObjects.push(dockBase);
                
                // Dock posts
                const postGeo = new THREE.CylinderGeometry(0.15, 0.15, 1.2, 8);
                const postMat = new THREE.MeshLambertMaterial({ color: 0x654321 });
                [[-2.5, -13], [2.5, -13], [-2.5, -15], [2.5, -15]].forEach(([x, z]) => {
                    const post = new THREE.Mesh(postGeo, postMat);
                    post.position.set(x, 0.6, z);
                    this.scene.add(post);
                    this.areaObjects.push(post);
                });
                
                // Fishing wizard permanently on dock
                const fishingWizBody = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.6, 1.4, 8),
                    new THREE.MeshLambertMaterial({ color: 0xf97316 })
                );
                fishingWizBody.position.set(0, 1.15, -14);
                fishingWizBody.castShadow = true;
                this.scene.add(fishingWizBody);
                this.areaObjects.push(fishingWizBody);
                
                const fishingWizFace = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 16, 16),
                    new THREE.MeshBasicMaterial({ color: 0x000000 })
                );
                fishingWizFace.position.set(0, 1.95, -13.9);
                this.scene.add(fishingWizFace);
                this.areaObjects.push(fishingWizFace);
                
                const fishingWizLeftEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffeb3b })
                );
                fishingWizLeftEye.position.set(0.15, 1.97, -13.62);
                this.scene.add(fishingWizLeftEye);
                this.areaObjects.push(fishingWizLeftEye);
                
                const fishingWizRightEye = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0xffeb3b })
                );
                fishingWizRightEye.position.set(-0.15, 1.97, -13.62);
                this.scene.add(fishingWizRightEye);
                this.areaObjects.push(fishingWizRightEye);
                
                const fishingWizHat = new THREE.Mesh(
                    new THREE.ConeGeometry(0.4, 1.2, 16),
                    new THREE.MeshLambertMaterial({ color: 0xf97316 })
                );
                fishingWizHat.position.set(0, 2.85, -14);
                fishingWizHat.castShadow = true;
                this.scene.add(fishingWizHat);
                this.areaObjects.push(fishingWizHat);
                
                // Fishing rod in wizard's hand
                const fishingRod = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.03, 0.03, 2.2, 8),
                    new THREE.MeshLambertMaterial({ color: 0x654321 })
                );
                fishingRod.position.set(0.6, 1.3, -14);
                fishingRod.rotation.z = -Math.PI / 3;
                fishingRod.castShadow = true;
                this.scene.add(fishingRod);
                this.areaObjects.push(fishingRod);
                
                this.spawnFish();
            },

            spawnFish() {
                if (this.fishingFish.length >= 6) return;
                const fishTypes = [
                    { icon: 'üêü', sp: 200, speed: 0.03, size: 0.6, color: 0xc0c0c0 }, // Original size
                    { icon: 'üê†', sp: 350, speed: 0.05, size: 0.5, color: 0xff8c42 },
                    { icon: 'üê°', sp: 500, speed: 0.07, size: 0.4, color: 0x4a90e2 },
                ];
                const type = fishTypes[Math.floor(Math.random() * fishTypes.length)];
                
                // Spawn fish in water only (inside radius 9 circle)
                const side = Math.random() < 0.5 ? -1 : 1;
                const x = side * 12;
                const z = (Math.random() - 0.5) * 12;
                
                // Create fish group
                const fishGroup = new THREE.Group();
                
                // Body (cylinder)
                const body = new THREE.Mesh(
                    new THREE.CylinderGeometry(type.size * 0.3, type.size * 0.3, type.size * 1.5, 8),
                    new THREE.MeshLambertMaterial({ color: type.color, emissive: type.color, emissiveIntensity: 0.2 })
                );
                body.rotation.z = Math.PI / 2;
                fishGroup.add(body);
                
                // Tail (triangle)
                const tailShape = new THREE.Shape();
                tailShape.moveTo(0, 0);
                tailShape.lineTo(-type.size * 0.6, type.size * 0.4);
                tailShape.lineTo(-type.size * 0.6, -type.size * 0.4);
                tailShape.lineTo(0, 0);
                const tailGeo = new THREE.ShapeGeometry(tailShape);
                const tail = new THREE.Mesh(
                    tailGeo,
                    new THREE.MeshLambertMaterial({ color: type.color, side: THREE.DoubleSide })
                );
                tail.position.set(type.size * -0.75, 0, 0);
                fishGroup.add(tail);
                
                // Top fin
                const topFinShape = new THREE.Shape();
                topFinShape.moveTo(0, 0);
                topFinShape.lineTo(type.size * 0.2, type.size * 0.3);
                topFinShape.lineTo(type.size * 0.3, 0);
                topFinShape.lineTo(0, 0);
                const topFinGeo = new THREE.ShapeGeometry(topFinShape);
                const topFin = new THREE.Mesh(
                    topFinGeo,
                    new THREE.MeshLambertMaterial({ color: type.color, side: THREE.DoubleSide })
                );
                topFin.position.set(0, type.size * 0.3, 0);
                topFin.rotation.x = Math.PI / 2;
                fishGroup.add(topFin);
                
                // Side fins
                const sideFinShape = new THREE.Shape();
                sideFinShape.moveTo(0, 0);
                sideFinShape.lineTo(type.size * 0.3, type.size * 0.15);
                sideFinShape.lineTo(type.size * 0.3, -type.size * 0.15);
                sideFinShape.lineTo(0, 0);
                const sideFinGeo = new THREE.ShapeGeometry(sideFinShape);
                
                const leftFin = new THREE.Mesh(
                    sideFinGeo,
                    new THREE.MeshLambertMaterial({ color: type.color, side: THREE.DoubleSide })
                );
                leftFin.position.set(type.size * 0.2, 0, type.size * 0.3);
                leftFin.rotation.y = Math.PI / 2;
                fishGroup.add(leftFin);
                
                const rightFin = new THREE.Mesh(
                    sideFinGeo,
                    new THREE.MeshLambertMaterial({ color: type.color, side: THREE.DoubleSide })
                );
                rightFin.position.set(type.size * 0.2, 0, -type.size * 0.3);
                rightFin.rotation.y = -Math.PI / 2;
                fishGroup.add(rightFin);
                
                fishGroup.position.set(x, 0.5, z);
                fishGroup.castShadow = true;
                this.scene.add(fishGroup);
                this.areaObjects.push(fishGroup);
                this.fishingFish.push({ mesh: fishGroup, x: x, z: z, targetX: -x, speed: type.speed, sp: type.sp, icon: type.icon, caught: false, lifetime: 0 });
            },

            createAstral() {
                this.scene.background = new THREE.Color(0x0a0a2e);
                
                // Dark space ground
                this.ground.material.color.setHex(0x0a0a2e);
                this.ground.material.transparent = true;
                this.ground.material.opacity = 0.3;
                
                // Galaxy dust clouds on ground
                const dustColors = [0x4b0082, 0x8b008b, 0x4169e1, 0x1e90ff, 0x9370db];
                for (let i = 0; i < 25; i++) {
                    const dust = new THREE.Mesh(
                        new THREE.CircleGeometry(3 + Math.random() * 4, 24),
                        new THREE.MeshBasicMaterial({ 
                            color: dustColors[Math.floor(Math.random() * dustColors.length)],
                            transparent: true,
                            opacity: 0.15
                        })
                    );
                    dust.position.set(
                        (Math.random() - 0.5) * 40,
                        0.02,
                        (Math.random() - 0.5) * 40
                    );
                    dust.rotation.x = -Math.PI / 2;
                    this.scene.add(dust);
                    this.areaObjects.push(dust);
                }
                
                // Stardust particles on ground
                for (let i = 0; i < 100; i++) {
                    const stardustSize = 0.05 + Math.random() * 0.1;
                    const stardust = new THREE.Mesh(
                        new THREE.CircleGeometry(stardustSize, 6),
                        new THREE.MeshBasicMaterial({ 
                            color: 0xffffff,
                            transparent: true,
                            opacity: 0.6
                        })
                    );
                    stardust.position.set(
                        (Math.random() - 0.5) * 30,
                        0.02,
                        (Math.random() - 0.5) * 30
                    );
                    stardust.rotation.x = -Math.PI / 2;
                    this.scene.add(stardust);
                    this.areaObjects.push(stardust);
                }
                
                // 300 White stars scattered across sky
                const starGeo = new THREE.SphereGeometry(0.05, 8, 8);
                const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                for (let i = 0; i < 300; i++) {
                    const star = new THREE.Mesh(starGeo, starMat);
                    star.position.set(
                        (Math.random() - 0.5) * 60,
                        Math.random() * 40 + 5,
                        (Math.random() - 0.5) * 60
                    );
                    this.scene.add(star);
                    this.areaObjects.push(star);
                }
                
                // Large moon with craters
                const moon = new THREE.Mesh(
                    new THREE.SphereGeometry(2.5, 16, 16),
                    new THREE.MeshLambertMaterial({ color: 0xcccccc, emissive: 0xcccccc, emissiveIntensity: 0.2 })
                );
                moon.position.set(-18, 10, -25);
                this.scene.add(moon);
                this.areaObjects.push(moon);
                
                // 8 Moon craters
                const craterGeo = new THREE.SphereGeometry(0.4, 8, 8);
                const craterMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
                for (let i = 0; i < 8; i++) {
                    const crater = new THREE.Mesh(craterGeo, craterMat);
                    const angle = (i / 8) * Math.PI * 2;
                    crater.position.set(
                        -18 + Math.cos(angle) * 2,
                        10 + Math.sin(angle) * 2,
                        -24
                    );
                    this.scene.add(crater);
                    this.areaObjects.push(crater);
                }
                
                // 20 Rotating asteroids
                const asteroidGeo = new THREE.DodecahedronGeometry(0.6, 0);
                for (let i = 0; i < 20; i++) {
                    const asteroidMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
                    const asteroid = new THREE.Mesh(asteroidGeo, asteroidMat);
                    asteroid.position.set(
                        (Math.random() - 0.5) * 40,
                        Math.random() * 20 + 3,
                        (Math.random() - 0.5) * 40
                    );
                    asteroid.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                    this.scene.add(asteroid);
                    this.areaObjects.push(asteroid);
                }
                
                // 10 Nebula clouds (colorful)
                const nebulaColors = [0xff69b4, 0x00ffff, 0x9370db, 0xff1493, 0x7fffd4];
                for (let i = 0; i < 10; i++) {
                    const nebula = new THREE.Mesh(
                        new THREE.SphereGeometry(3, 16, 16),
                        new THREE.MeshBasicMaterial({ 
                            color: nebulaColors[i % nebulaColors.length],
                            transparent: true,
                            opacity: 0.1
                        })
                    );
                    nebula.position.set(
                        (Math.random() - 0.5) * 50,
                        Math.random() * 30 + 5,
                        (Math.random() - 0.5) * 50
                    );
                    this.scene.add(nebula);
                    this.areaObjects.push(nebula);
                }
                
                // 4 Floating crystal platforms
                const crystalPositions = [[-6, -6], [6, -6], [-6, 6], [6, 6]];
                crystalPositions.forEach(([x, z]) => {
                    const crystal = new THREE.Mesh(
                        new THREE.OctahedronGeometry(0.8, 0),
                        new THREE.MeshLambertMaterial({ color: 0x9370db, emissive: 0x9370db, emissiveIntensity: 0.5 })
                    );
                    crystal.position.set(x, 2, z);
                    crystal.rotation.set(Math.random(), Math.random(), Math.random());
                    this.scene.add(crystal);
                    this.areaObjects.push(crystal);
                });
                
                // 6 Colorful Saturns with rotating rings
                const colors = [0xff6b6b, 0x4ecdc4, 0xffe66d, 0xa8e6cf, 0xc7ceea, 0xffa07a];
                const spValues = [100, 200, 350, 500, 800, 1200];
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const x = Math.cos(angle) * 5;
                    const z = Math.sin(angle) * 5;
                    
                    const planet = new THREE.Mesh(
                        new THREE.SphereGeometry(0.8, 16, 16),
                        new THREE.MeshLambertMaterial({ color: colors[i], emissive: colors[i], emissiveIntensity: 0.3 })
                    );
                    planet.position.set(x, 1.5, z);
                    planet.castShadow = true;
                    this.scene.add(planet);
                    this.areaObjects.push(planet);
                    
                    const ring = new THREE.Mesh(
                        new THREE.TorusGeometry(1.2, 0.15, 8, 24),
                        new THREE.MeshLambertMaterial({ color: colors[i], emissive: colors[i], emissiveIntensity: 0.2, opacity: 0.7, transparent: true })
                    );
                    ring.position.set(x, 1.5, z);
                    ring.rotation.x = Math.PI / 2.5;
                    this.scene.add(ring);
                    this.areaObjects.push(ring);
                    
                    this.astralSaturns.push({ planet, ring, x, z, burst: false, spValue: spValues[i], color: colors[i] });
                }
            },

            createWizard() {
                if (this.wizard) {
                    Object.values(this.wizard).forEach(part => { if (part && part.parent) this.scene.remove(part); });
                }
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 1.4, 8), new THREE.MeshLambertMaterial({ color: 0xf97316 }));
                body.position.set(-6, 0.7, 0);
                body.castShadow = true;
                this.scene.add(body);
                const face = new THREE.Mesh(new THREE.SphereGeometry(0.35, 16, 16), new THREE.MeshBasicMaterial({ color: 0x000000 }));
                face.position.set(-6, 1.5, 0.1);
                this.scene.add(face);
                const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffeb3b }));
                leftEye.position.set(-5.85, 1.52, 0.32);
                this.scene.add(leftEye);
                const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshBasicMaterial({ color: 0xffeb3b }));
                rightEye.position.set(-6.15, 1.52, 0.32);
                this.scene.add(rightEye);
                const hat = new THREE.Mesh(new THREE.ConeGeometry(0.4, 1.2, 16), new THREE.MeshLambertMaterial({ color: 0xf97316 }));
                hat.position.set(-6, 2.4, 0);
                hat.castShadow = true;
                this.scene.add(hat);
                const staff = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.8, 8), new THREE.MeshLambertMaterial({ color: 0x654321 }));
                staff.position.set(-5.35, 0.9, 0);
                staff.castShadow = true;
                this.scene.add(staff);
                this.wizard = { body, face, leftEye, rightEye, hat, staff, bobOffset: 0, baseX: -6, baseZ: 0 };
                this.wizardTarget = { x: -6, z: 0 };
            },

            moveWizardTo(x, z) {
                let targetX = x > 0 ? x - 1.5 : x + 1.5;
                let targetZ = z;
                
                // Boundary check for fishing area - keep wizard on brown sandy beach ONLY
                if (this.currentArea === 'fishing') {
                    const distFromCenter = Math.sqrt(targetX * targetX + targetZ * targetZ);
                    // Beach is radius 14-26 (brown sand ring), water inside radius 14
                    if (distFromCenter < 14) {
                        // In water! Push to inner edge of beach
                        const angle = Math.atan2(targetZ, targetX);
                        targetX = Math.cos(angle) * 14.5; // Inner beach edge
                        targetZ = Math.sin(angle) * 14.5;
                    } else if (distFromCenter > 26) {
                        // Beyond beach! Pull back to outer edge
                        const angle = Math.atan2(targetZ, targetX);
                        targetX = Math.cos(angle) * 25.5; // Outer beach edge
                        targetZ = Math.sin(angle) * 25.5;
                    }
                }
                
                this.wizardTarget = { x: targetX, z: targetZ };
                this.wizardMoving = true;
            },

            updateWizardPosition() {
                if (!this.wizard) return;
                const dx = this.wizardTarget.x - this.wizard.baseX;
                const dz = this.wizardTarget.z - this.wizard.baseZ;
                const distance = Math.sqrt(dx * dx + dz * dz);
                if (distance > 0.1) {
                    const speed = 0.2; // Smooth speed
                    this.wizard.baseX += dx * speed;
                    this.wizard.baseZ += dz * speed;
                    const angle = Math.atan2(dx, dz);
                    this.wizard.body.rotation.y = angle;
                    this.wizard.face.rotation.y = angle;
                    this.wizard.hat.rotation.y = angle;
                    this.wizardMoving = true;
                } else {
                    this.wizardMoving = false;
                }
            },

            setupEventListeners() {
                const canvas = document.getElementById('game-canvas');
                canvas.addEventListener('click', (e) => this.onCanvasClick(e));
                canvas.addEventListener('touchend', (e) => this.onCanvasClick(e));
            },

            onCanvasClick(e) {
                e.preventDefault();
                e.stopPropagation();
                const rect = this.renderer.domElement.getBoundingClientRect();
                const x = e.clientX || (e.changedTouches && e.changedTouches[0].clientX);
                const y = e.clientY || (e.changedTouches && e.changedTouches[0].clientY);
                this.mouse.x = ((x - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((y - rect.top) / rect.height) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.camera);
                
                if (this.currentArea === 'farm') {
                    // Check for rat thief clicks first (priority)
                    let ratCaught = false;
                    this.ratThieves.forEach((rat, i) => {
                        if (rat.state !== 'caught') {
                            const hits = this.raycaster.intersectObjects([rat.mesh, rat.ear1, rat.ear2]);
                            if (hits.length > 0) {
                                ratCaught = true;
                                rat.state = 'caught';
                                
                                // Reward the player!
                                const gain = rat.bonusReward;
                                this.essence += gain;
                                this.stats.totalEssenceEarned += gain;
                                this.xp += 100;
                                this.checkLevel();
                                
                                // Return the stolen seed
                                const tier = rat.stolenSeedTier || 1;
                                this.seeds[tier] = (this.seeds[tier] || 0) + 1;
                                
                                this.showToast(`üêÄ Caught the rat! +${gain} SP + Tier ${tier} seed returned!`);
                                
                                // Remove rat
                                this.scene.remove(rat.mesh);
                                this.scene.remove(rat.ear1);
                                this.scene.remove(rat.ear2);
                                const idx1 = this.areaObjects.indexOf(rat.mesh);
                                if (idx1 > -1) this.areaObjects.splice(idx1, 1);
                                const idx2 = this.areaObjects.indexOf(rat.ear1);
                                if (idx2 > -1) this.areaObjects.splice(idx2, 1);
                                const idx3 = this.areaObjects.indexOf(rat.ear2);
                                if (idx3 > -1) this.areaObjects.splice(idx3, 1);
                                this.ratThieves.splice(i, 1);
                                
                                this.checkAchievements();
                                this.renderToolbar();
                                this.renderStore();
                                this.updateUI();
                            }
                        }
                    });
                    
                    if (!ratCaught) {
                        this.farmPlots.forEach(plot => {
                            if (plot.seed && plot.growthTime >= plot.growthNeeded && plot.plantMesh) {
                                // Check both plot mesh AND plant mesh for better click detection
                                const plotHits = this.raycaster.intersectObject(plot.mesh);
                                const plantHits = this.raycaster.intersectObject(plot.plantMesh, true); // true = check children
                                if (plotHits.length > 0 || plantHits.length > 0) {
                                    this.harvestPlant(plot);
                                }
                            }
                        });
                    }
                } else if (this.currentArea === 'mine') {
                    this.mineRocks.forEach(rock => {
                        if (rock.hp > 0) {
                            const hits = this.raycaster.intersectObject(rock.mesh);
                            if (hits.length > 0) this.mineRock(rock);
                        }
                    });
                } else if (this.currentArea === 'forest') {
                    if (this.dragon && this.fishInventory > 0) {
                        const hits = this.raycaster.intersectObjects([this.dragon.body, this.dragon.head]);
                        if (hits.length > 0) {
                            this.feedDragon();
                            return;
                        }
                    }
                    this.forestTrolls.forEach(troll => {
                        if (troll.hp > 0) {
                            const hits = this.raycaster.intersectObjects([troll.body, troll.head]);
                            if (hits.length > 0) this.attackTroll(troll);
                        }
                    });
                } else if (this.currentArea === 'fishing') {
                    this.fishingFish.forEach(fish => {
                        if (!fish.caught) {
                            const hits = this.raycaster.intersectObject(fish.mesh, true); // true = recursive check children
                            if (hits.length > 0) this.catchFish(fish);
                        }
                    });
                } else if (this.currentArea === 'astral') {
                    this.astralSaturns.forEach(saturn => {
                        if (!saturn.burst) {
                            const hits = this.raycaster.intersectObjects([saturn.planet, saturn.ring]);
                            if (hits.length > 0) this.burstSaturn(saturn);
                        }
                    });
                }
            },

            feedDragon() {
                if (this.fishInventory <= 0) return;
                this.fishInventory--;
                this.stats.fishFedToDragon++;
                
                const gain = Math.floor((300 + Math.random() * 200) * (1 + this.essenceMult));
                this.essence += gain;
                this.stats.totalEssenceEarned += gain;
                this.xp += 75;
                this.checkLevel();
                
                // Dragon animation
                if (this.dragon) {
                    this.dragon.head.material.emissiveIntensity = 0.8;
                    setTimeout(() => { if (this.dragon) this.dragon.head.material.emissiveIntensity = 0.2; }, 300);
                }
                
                this.showFloatingNumber(0, 4, -8, gain);
                this.checkAchievements();
                this.renderStore();
                this.renderToolbar();
                this.updateUI();
            },

            plantSeed(plot, tier) {
                if (!this.seeds[tier] || this.seeds[tier] <= 0 || plot.seed) return;
                this.moveWizardTo(plot.x, plot.z);
                plot.seed = tier;
                plot.growthTime = 0;
                this.seeds[tier]--;
                
                // Create unique plant for each tier
                const plantGroup = new THREE.Group();
                const color = SEED_TIERS[tier - 1].color;
                const stem = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.06, 0.09, 0.5, 8),
                    new THREE.MeshLambertMaterial({ color: 0x3d6b2f })
                );
                stem.position.y = 0.25;
                plantGroup.add(stem);
                
                // Add green leaves to stem
                for (let i = 0; i < 4; i++) {
                    const leaf = new THREE.Mesh(
                        new THREE.BoxGeometry(0.08, 0.15, 0.03),
                        new THREE.MeshLambertMaterial({ color: 0x5d8c3f })
                    );
                    const angle = (i / 4) * Math.PI * 2;
                    leaf.position.set(
                        Math.cos(angle) * 0.08,
                        0.2 + i * 0.08,
                        Math.sin(angle) * 0.08
                    );
                    leaf.rotation.z = angle + Math.PI / 4;
                    plantGroup.add(leaf);
                }
                
                plantGroup.userData = { tier, swayPhase: Math.random() * Math.PI * 2 };
                
                if (tier === 1) {
                    // Tier 1: Blooming flower with colorful petals
                    const center = new THREE.Mesh(
                        new THREE.SphereGeometry(0.12, 8, 8),
                        new THREE.MeshLambertMaterial({ color: 0xffeb3b, emissive: 0xffeb3b, emissiveIntensity: 0.5 })
                    );
                    center.position.y = 0.5;
                    plantGroup.add(center);
                    
                    // 6 colorful petals
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2;
                        const petal = new THREE.Mesh(
                            new THREE.SphereGeometry(0.12, 8, 8),
                            new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.4 })
                        );
                        petal.position.set(
                            Math.cos(angle) * 0.22,
                            0.5,
                            Math.sin(angle) * 0.22
                        );
                        petal.scale.set(1.2, 0.9, 0.8);
                        plantGroup.add(petal);
                    }
                } else if (tier === 2) {
                    // Tier 2: Double-layer rose-like flower
                    const center = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 8, 8),
                        new THREE.MeshLambertMaterial({ color: 0xffe74c, emissive: 0xffe74c, emissiveIntensity: 0.6 })
                    );
                    center.position.y = 0.55;
                    plantGroup.add(center);
                    
                    // Outer layer - 8 large petals
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const petal = new THREE.Mesh(
                            new THREE.SphereGeometry(0.13, 8, 8),
                            new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.5 })
                        );
                        petal.position.set(
                            Math.cos(angle) * 0.25,
                            0.5,
                            Math.sin(angle) * 0.25
                        );
                        petal.scale.set(1.3, 1.1, 0.7);
                        petal.rotation.z = Math.PI / 6;
                        plantGroup.add(petal);
                    }
                    
                    // Inner layer - 6 slightly smaller petals
                    for (let i = 0; i < 6; i++) {
                        const angle = (i / 6) * Math.PI * 2 + Math.PI / 6;
                        const petal = new THREE.Mesh(
                            new THREE.SphereGeometry(0.1, 8, 8),
                            new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.4 })
                        );
                        petal.position.set(
                            Math.cos(angle) * 0.15,
                            0.55,
                            Math.sin(angle) * 0.15
                        );
                        petal.scale.set(1.1, 0.9, 0.6);
                        plantGroup.add(petal);
                    }
                } else if (tier === 3) {
                    // Tier 3: Crystal flower cluster with light glow
                    const base = new THREE.Mesh(
                        new THREE.BoxGeometry(0.15, 0.3, 0.15),
                        new THREE.MeshLambertMaterial({ color: 0x7cb342 })
                    );
                    base.position.y = 0.15;
                    plantGroup.add(base);
                    
                    for (let i = 0; i < 4; i++) {
                        const crystal = new THREE.Mesh(
                            new THREE.ConeGeometry(0.1, 0.6, 6),
                            new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.6 })
                        );
                        const angle = (i / 4) * Math.PI * 2;
                        crystal.position.set(
                            Math.cos(angle) * 0.15,
                            0.45,
                            Math.sin(angle) * 0.15
                        );
                        crystal.rotation.z = angle + Math.PI * 0.2;
                        plantGroup.add(crystal);
                    }
                    
                    // Top crystal point
                    const topCrystal = new THREE.Mesh(
                        new THREE.ConeGeometry(0.08, 0.4, 6),
                        new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.8 })
                    );
                    topCrystal.position.y = 0.7;
                    plantGroup.add(topCrystal);
                } else if (tier === 4) {
                    // Tier 4: Lotus-like floating flower
                    const base = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.2, 0.15, 0.1, 8),
                        new THREE.MeshLambertMaterial({ color: 0x4a7c3a })
                    );
                    base.position.y = 0.15;
                    plantGroup.add(base);
                    
                    // Layered petals
                    for (let layer = 0; layer < 2; layer++) {
                        for (let i = 0; i < 6; i++) {
                            const angle = (i / 6) * Math.PI * 2 + layer * 0.2;
                            const petal = new THREE.Mesh(
                                new THREE.BoxGeometry(0.15, 0.25, 0.05),
                                new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.4 })
                            );
                            petal.position.set(
                                Math.cos(angle) * (0.2 - layer * 0.05),
                                0.25 + layer * 0.1,
                                Math.sin(angle) * (0.2 - layer * 0.05)
                            );
                            petal.rotation.y = angle;
                            petal.rotation.x = 0.5 + layer * 0.2;
                            plantGroup.add(petal);
                        }
                    }
                } else if (tier === 5) {
                    // Tier 5: Thorny vine spiral
                    const base = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.06, 0.08, 0.6, 8),
                        new THREE.MeshLambertMaterial({ color: 0x4a3a2a })
                    );
                    base.position.y = 0.3;
                    plantGroup.add(base);
                    
                    // Spiral thorns
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 4;
                        const height = i * 0.08;
                        const thorn = new THREE.Mesh(
                            new THREE.ConeGeometry(0.06, 0.15, 6),
                            new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.6 })
                        );
                        thorn.position.set(
                            Math.cos(angle) * 0.1,
                            0.1 + height,
                            Math.sin(angle) * 0.1
                        );
                        thorn.rotation.z = Math.PI / 3;
                        plantGroup.add(thorn);
                    }
                } else if (tier === 6) {
                    // Tier 6: Storm cloud bloom
                    const cloud = new THREE.Mesh(
                        new THREE.SphereGeometry(0.25, 8, 8),
                        new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.5 })
                    );
                    cloud.position.y = 0.4;
                    cloud.scale.set(1, 0.6, 1);
                    plantGroup.add(cloud);
                    
                    // Lightning bolts
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const bolt = new THREE.Mesh(
                            new THREE.BoxGeometry(0.03, 0.3, 0.03),
                            new THREE.MeshBasicMaterial({ color: 0xffff00, emissive: 0xffff00 })
                        );
                        bolt.position.set(
                            Math.cos(angle) * 0.2,
                            0.2,
                            Math.sin(angle) * 0.2
                        );
                        bolt.rotation.z = angle + Math.PI / 4;
                        plantGroup.add(bolt);
                    }
                } else if (tier === 7) {
                    // Tier 7: Crystal tree
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.08, 0.1, 0.5, 6),
                        new THREE.MeshLambertMaterial({ color: 0x6a5acd })
                    );
                    trunk.position.y = 0.25;
                    plantGroup.add(trunk);
                    
                    // Crystalline crown
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2;
                        const crystal = new THREE.Mesh(
                            new THREE.OctahedronGeometry(0.12, 0),
                            new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.8 })
                        );
                        crystal.position.set(
                            Math.cos(angle) * 0.15,
                            0.55,
                            Math.sin(angle) * 0.15
                        );
                        plantGroup.add(crystal);
                    }
                } else if (tier === 8) {
                    // Tier 8: Void portal flower
                    const portal = new THREE.Mesh(
                        new THREE.TorusGeometry(0.2, 0.06, 8, 12),
                        new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 0.9 })
                    );
                    portal.position.y = 0.4;
                    portal.rotation.x = Math.PI / 2;
                    plantGroup.add(portal);
                    
                    const core = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 8, 8),
                        new THREE.MeshBasicMaterial({ color: 0x000000 })
                    );
                    core.position.y = 0.4;
                    plantGroup.add(core);
                } else if (tier === 9) {
                    // Tier 9: Moonflower
                    const crescent = new THREE.Mesh(
                        new THREE.TorusGeometry(0.18, 0.08, 8, 12, Math.PI * 1.5),
                        new THREE.MeshLambertMaterial({ color, emissive: color, emissiveIntensity: 1.0 })
                    );
                    crescent.position.y = 0.4;
                    crescent.rotation.z = -Math.PI / 4;
                    plantGroup.add(crescent);
                    
                    // Stars around it
                    for (let i = 0; i < 3; i++) {
                        const star = new THREE.Mesh(
                            new THREE.OctahedronGeometry(0.05, 0),
                            new THREE.MeshBasicMaterial({ color: 0xffffff, emissive: 0xffffff })
                        );
                        star.position.set(
                            (Math.random() - 0.5) * 0.3,
                            0.5 + Math.random() * 0.2,
                            (Math.random() - 0.5) * 0.3
                        );
                        plantGroup.add(star);
                    }
                } else if (tier === 10) {
                    // Tier 10: Stardust constellation
                    // Central star
                    const center = new THREE.Mesh(
                        new THREE.OctahedronGeometry(0.15, 1),
                        new THREE.MeshBasicMaterial({ color, emissive: color, emissiveIntensity: 1.5 })
                    );
                    center.position.y = 0.5;
                    plantGroup.add(center);
                    
                    // Orbiting particles
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        const particle = new THREE.Mesh(
                            new THREE.SphereGeometry(0.04, 6, 6),
                            new THREE.MeshBasicMaterial({ color: 0xffffff, emissive: 0xffffff })
                        );
                        particle.position.set(
                            Math.cos(angle) * 0.25,
                            0.5,
                            Math.sin(angle) * 0.25
                        );
                        plantGroup.add(particle);
                    }
                }
                
                plantGroup.position.set(plot.x, 0.6, plot.z);
                plantGroup.scale.set(0.8, 0.8, 0.8); // Start visible
                plantGroup.castShadow = true;
                this.scene.add(plantGroup);
                this.areaObjects.push(plantGroup);
                plot.plantMesh = plantGroup;
                this.renderToolbar();
                this.renderStore();
            },

            harvestPlant(plot) {
                this.moveWizardTo(plot.x, plot.z);
                const tier = plot.seed;
                const gain = Math.floor(SEED_TIERS[tier - 1].sp * (1 + this.essenceMult));
                this.essence += gain;
                this.stats.totalEssenceEarned += gain;
                this.stats.totalHarvests++;
                this.xp += tier * 6;
                this.checkLevel();
                this.seeds[tier] = (this.seeds[tier] || 0) + 1;
                if (tier < 10) this.seeds[tier + 1] = (this.seeds[tier + 1] || 0) + 1;
                if (plot.plantMesh) {
                    this.scene.remove(plot.plantMesh);
                    const idx = this.areaObjects.indexOf(plot.plantMesh);
                    if (idx > -1) this.areaObjects.splice(idx, 1);
                    plot.plantMesh = null;
                }
                plot.seed = null;
                plot.growthTime = 0;
                this.checkAchievements();
                this.renderToolbar();
                this.renderStore();
                this.updateUI();
            },

            mineRock(rock) {
                this.moveWizardTo(rock.x, rock.z);
                rock.hp = Math.max(0, rock.hp - 20);
                const hpPercent = rock.hp / rock.maxHP;
                rock.mesh.scale.set(0.6 + hpPercent * 0.4, 0.6 + hpPercent * 0.4, 0.6 + hpPercent * 0.4);
                rock.hpBarFill.scale.x = hpPercent;
                rock.hpBarFill.position.x = rock.x - (1.2 * (1 - hpPercent) / 2);
                if (hpPercent > 0.5) rock.hpBarFill.material.color.setHex(0x22c55e);
                else if (hpPercent > 0.25) rock.hpBarFill.material.color.setHex(0xeab308);
                else rock.hpBarFill.material.color.setHex(0xef4444);
                if (rock.hp === 0) {
                    const baseReward = 30 + Math.random() * 20;
                    const levelBonus = this.level * 5;
                    const gain = Math.floor((baseReward + levelBonus) * (1 + this.essenceMult));
                    this.essence += gain;
                    this.stats.totalEssenceEarned += gain;
                    this.stats.totalRocksMined++;
                    this.xp += 8;
                    this.checkLevel();
                    this.checkAchievements();
                    this.updateUI();
                    this.showFloatingNumber(rock.x, 1, rock.z, gain);
                    rock.mesh.visible = false;
                    rock.hpBarBg.visible = false;
                    rock.hpBarFill.visible = false;
                    setTimeout(() => {
                        // Randomize respawn position
                        const newX = (Math.random() - 0.5) * 30;
                        const newZ = (Math.random() - 0.5) * 30;
                        rock.x = newX;
                        rock.z = newZ;
                        rock.mesh.position.set(newX, 0.8, newZ);
                        rock.hpBarBg.position.set(newX, 1.8, newZ);
                        rock.hpBarFill.position.set(newX, 1.8, newZ + 0.01);
                        
                        rock.hp = rock.maxHP;
                        rock.mesh.scale.set(1, 1, 1);
                        rock.mesh.visible = true;
                        rock.hpBarBg.visible = true;
                        rock.hpBarFill.visible = true;
                        rock.hpBarFill.scale.x = 1;
                        rock.hpBarFill.material.color.setHex(0x22c55e);
                    }, 10000);
                }
            },

            attackTroll(troll) {
                this.moveWizardTo(troll.x, troll.z);
                const dmg = 25 + this.baseDamage + this.level * 3;
                troll.hp = Math.max(0, troll.hp - dmg);
                const hpPercent = troll.hp / troll.maxHP;
                troll.hpBarFill.scale.x = hpPercent;
                troll.hpBarFill.position.x = troll.x - (1.5 * (1 - hpPercent) / 2);
                if (hpPercent > 0.5) troll.hpBarFill.material.color.setHex(0xef4444);
                else if (hpPercent > 0.25) troll.hpBarFill.material.color.setHex(0xf97316);
                else troll.hpBarFill.material.color.setHex(0xfbbf24);
                troll.body.material.color.setHex(0xff0000);
                setTimeout(() => troll.body.material.color.setHex(0x7bed7b), 150);
                if (troll.hp === 0) {
                    const baseReward = 150 + Math.random() * 100;
                    const levelBonus = this.level * 20;
                    const gain = Math.floor((baseReward + levelBonus) * (1 + this.essenceMult));
                    this.essence += gain;
                    this.stats.totalEssenceEarned += gain;
                    this.stats.totalTrollsKilled++;
                    this.xp += 40;
                    this.checkLevel();
                    const randTier = Math.min(10, Math.max(2, Math.floor(this.level / 2) + Math.floor(Math.random() * 4)));
                    this.seeds[randTier] = (this.seeds[randTier] || 0) + 1;
                    this.showFloatingNumber(troll.x, 2, troll.z, gain);
                    troll.body.visible = false;
                    troll.head.visible = false;
                    if (troll.nose) troll.nose.visible = false;
                    if (troll.leftEye) troll.leftEye.visible = false;
                    if (troll.rightEye) troll.rightEye.visible = false;
                    if (troll.leftArm) troll.leftArm.visible = false;
                    if (troll.rightArm) troll.rightArm.visible = false;
                    if (troll.leftLeg) troll.leftLeg.visible = false;
                    if (troll.rightLeg) troll.rightLeg.visible = false;
                    troll.hpBarBg.visible = false;
                    troll.hpBarFill.visible = false;
                    this.checkAchievements();
                    this.renderToolbar();
                    this.renderStore();
                    this.updateUI();
                    setTimeout(() => {
                        // Randomize respawn position (avoid dragon at 0, -8)
                        let newX, newZ;
                        do {
                            newX = (Math.random() - 0.5) * 24;
                            newZ = Math.random() * 16 + 4;
                        } while (Math.sqrt(newX * newX + (newZ + 8) * (newZ + 8)) < 6);
                        
                        troll.x = newX;
                        troll.z = newZ;
                        troll.body.position.set(newX, 1.3, newZ);
                        troll.head.position.set(newX, 2.7, newZ);
                        if (troll.nose) troll.nose.position.set(newX, 2.7, newZ + 0.5);
                        if (troll.leftEye) troll.leftEye.position.set(newX - 0.2, 2.8, newZ + 0.35);
                        if (troll.rightEye) troll.rightEye.position.set(newX + 0.2, 2.8, newZ + 0.35);
                        if (troll.leftArm) troll.leftArm.position.set(newX - 0.9, 1.3, newZ);
                        if (troll.rightArm) troll.rightArm.position.set(newX + 0.9, 1.3, newZ);
                        if (troll.leftLeg) troll.leftLeg.position.set(newX - 0.4, 0.6, newZ);
                        if (troll.rightLeg) troll.rightLeg.position.set(newX + 0.4, 0.6, newZ);
                        troll.hpBarBg.position.set(newX, 3.6, newZ);
                        troll.hpBarFill.position.set(newX, 3.6, newZ + 0.01);
                        
                        troll.hp = troll.maxHP;
                        troll.body.visible = true;
                        troll.head.visible = true;
                        if (troll.nose) troll.nose.visible = true;
                        if (troll.leftEye) troll.leftEye.visible = true;
                        if (troll.rightEye) troll.rightEye.visible = true;
                        if (troll.leftArm) troll.leftArm.visible = true;
                        if (troll.rightArm) troll.rightArm.visible = true;
                        if (troll.leftLeg) troll.leftLeg.visible = true;
                        if (troll.rightLeg) troll.rightLeg.visible = true;
                        troll.hpBarBg.visible = true;
                        troll.hpBarFill.visible = true;
                        troll.hpBarFill.scale.x = 1;
                        troll.hpBarFill.material.color.setHex(0xef4444);
                    }, 8000);
                } else if (troll.attackCooldown <= 0) {
                    const diffMult = this.getDifficultyMultiplier();
                    let trollDmg = Math.floor((10 + Math.random() * 15) * diffMult);
                    this.hp = Math.max(0, this.hp - trollDmg);
                    this.updateUI();
                    if (this.hp === 0) this.die();
                    troll.attackCooldown = 1500;
                }
            },

            catchFish(fish) {
                if (fish.caught) return;
                
                // Cast fishing line from dock wizard to fish
                fish.caught = true;
                
                // Create fishing line from dock wizard (at 0, 1.95, -10) to fish
                const lineGeometry = new THREE.BufferGeometry();
                const wizardPos = new THREE.Vector3(0, 1.95, -14);
                const fishPos = new THREE.Vector3(fish.x, 0.5, fish.z);
                lineGeometry.setFromPoints([wizardPos, fishPos]);
                
                const lineMaterial = new THREE.LineBasicMaterial({ 
                    color: 0x654321, 
                    linewidth: 3,
                    transparent: true,
                    opacity: 0.8
                });
                const fishingLine = new THREE.Line(lineGeometry, lineMaterial);
                this.scene.add(fishingLine);
                this.areaObjects.push(fishingLine);
                
                // Animate line and catch fish after delay
                setTimeout(() => {
                    this.scene.remove(fishingLine);
                    const idx = this.areaObjects.indexOf(fishingLine);
                    if (idx > -1) this.areaObjects.splice(idx, 1);
                    
                    // RNG - 30% chance fish escapes!
                    const catchChance = 0.8; // 80% success rate
                    if (Math.random() > catchChance) {
                        // Fish escaped!
                        fish.caught = false; // Allow it to swim away
                        this.showToast(`${fish.icon} The fish escaped!`);
                        return;
                    }
                    
                    // Successfully caught!
                    this.fishInventory++;
                    const gain = Math.floor(fish.sp * (1 + this.essenceMult + this.fishLuck));
                    this.essence += gain;
                    this.stats.totalEssenceEarned += gain;
                    this.stats.fishCaught++;
                    this.xp += 60;
                    this.checkLevel();
                    
                    this.scene.remove(fish.mesh);
                    const fishIdx = this.areaObjects.indexOf(fish.mesh);
                    if (fishIdx > -1) this.areaObjects.splice(fishIdx, 1);
                    const fIdx = this.fishingFish.indexOf(fish);
                    if (fIdx > -1) this.fishingFish.splice(fIdx, 1);
                    
                    this.showFloatingNumber(fish.x, 1, fish.z, gain);
                    
                    if (!this.shownFirstFishNotif) {
                        this.shownFirstFishNotif = true;
                        const notif = document.createElement('div');
                        notif.className = 'weather-notification';
                        notif.style.background = 'linear-gradient(135deg, #ffd700, #f4a261)';
                        notif.innerHTML = `<div class="weather-notification-title">üêâ NEW FEATURE!</div><div class="weather-notification-text">You can now feed fish to the DRAGON in the Forest for big rewards! üêâ</div>`;
                        document.body.appendChild(notif);
                        setTimeout(() => notif.remove(), 6000);
                    }
                    
                    this.checkAchievements();
                    this.renderStore();
                    this.renderToolbar();
                    this.updateUI();
                }, 800); // Line visible for 800ms
            },

            burstSaturn(saturn) {
                if (saturn.burst) return;
                this.moveWizardTo(saturn.x, saturn.z);
                saturn.burst = true;
                const gain = Math.floor(saturn.spValue * (1 + this.essenceMult));
                this.essence += gain;
                this.stats.totalEssenceEarned += gain;
                this.stats.saturnsBurst++;
                this.xp += 50;
                this.checkLevel();
                saturn.planet.visible = false;
                saturn.ring.visible = false;
                this.showFloatingNumber(saturn.x, 2, saturn.z, gain);
                this.checkAchievements();
                this.updateUI();
                setTimeout(() => {
                    saturn.burst = false;
                    saturn.planet.visible = true;
                    saturn.ring.visible = true;
                }, 10000);
            },

            die() {
                const lost = Math.floor(this.essence / 2);
                this.essence -= lost;
                this.hp = this.maxHP;
                this.stats.deathCount++;
                this.showToast(`üíÄ Lost ${lost} SP!`);
                this.updateUI();
            },

            checkLevel() {
                while (this.xp >= this.xpNeeded) {
                    this.xp -= this.xpNeeded;
                    this.level++;
                    this.xpNeeded = Math.floor(this.xpNeeded * 1.35);
                    this.maxHP += 15;
                    this.hp = this.maxHP;
                    this.showToast(`üéâ Level ${this.level}!`);
                    this.checkAchievements();
                }
                this.updateUI();
            },

            switchArea(area) {
                if (area === 'mine' && !this.unlockedAreas.mine) {
                    if (this.essence >= 200) {
                        this.essence -= 200;
                        this.unlockedAreas.mine = true;
                        this.showToast('‚õèÔ∏è Mine unlocked!');
                        this.updateUI();
                        this.updateAreaTabs();
                    } else {
                        this.showToast('Need 200 SP');
                        return;
                    }
                } else if (area === 'forest' && !this.unlockedAreas.forest) {
                    if (this.essence >= 1000) {
                        this.essence -= 1000;
                        this.unlockedAreas.forest = true;
                        this.showToast('üå≤ Forest unlocked!');
                        this.updateUI();
                        this.updateAreaTabs();
                    } else {
                        this.showToast('Need 1000 SP');
                        return;
                    }
                } else if (area === 'fishing' && !this.unlockedAreas.fishing) {
                    if (this.essence >= 3000) {
                        this.essence -= 3000;
                        this.unlockedAreas.fishing = true;
                        this.showToast('üé£ Fishing unlocked!');
                        this.updateUI();
                        this.updateAreaTabs();
                    } else {
                        this.showToast('Need 3000 SP');
                        return;
                    }
                } else if (area === 'astral' && !this.unlockedAreas.astral) {
                    const required = ACHIEVEMENTS.filter(a => a.id !== 'true_master').length;
                    if (this.completedAchievements.length >= required) {
                        this.unlockedAreas.astral = true;
                        this.showToast('‚ú® Astral unlocked!');
                        this.updateAreaTabs();
                    } else {
                        this.showToast(`Need ${required - this.completedAchievements.length} more!`);
                        return;
                    }
                }
                this.currentArea = area;
                this.createWorld();
                if (this.wizard) {
                    if (area === 'fishing') {
                        // Hide main wizard in fishing area (fishing wizard on dock will be visible instead)
                        Object.values(this.wizard).forEach(part => {
                            if (part && part.visible !== undefined) part.visible = false;
                        });
                    } else {
                        // Show main wizard in other areas
                        Object.values(this.wizard).forEach(part => {
                            if (part && part.visible !== undefined) part.visible = true;
                        });
                        this.wizard.baseX = -6;
                        this.wizard.baseZ = 0;
                        this.wizardTarget = { x: -6, z: 0 };
                    }
                }
                // Reset camera for forest to focus on wizard area
                if (area === 'forest') {
                    this.cameraTarget.x = 0;
                    this.cameraTarget.z = 8; // Focus more forward where trolls spawn
                }
                this.renderToolbar();
            },

            showSkillDetail(id) {
                const sk = SKILLS.find(s => s.id === id);
                if (!sk) return;
                const purchased = this.purchasedSkills.includes(id);
                let canBuy = !purchased && this.essence >= sk.cost;
                let requiresText = '';
                if (sk.requires) {
                    const reqs = Array.isArray(sk.requires) ? sk.requires : [sk.requires];
                    canBuy = canBuy && reqs.every(r => this.purchasedSkills.includes(r));
                    if (!reqs.every(r => this.purchasedSkills.includes(r))) {
                        const reqNames = reqs.map(r => SKILLS.find(s => s.id === r)?.name || r);
                        requiresText = `Requires: ${reqNames.join(', ')}`;
                    }
                }
                const content = document.getElementById('skill-detail-content');
                content.innerHTML = `
                    <div class="skill-detail-icon">${sk.icon}</div>
                    <div class="skill-detail-name">${sk.name}</div>
                    <div class="skill-detail-desc">${sk.desc}</div>
                    ${requiresText ? `<div class="skill-detail-requires">${requiresText}</div>` : ''}
                    <div class="skill-detail-cost">${purchased ? '‚úÖ Purchased' : `Cost: ${sk.cost} SP`}</div>
                    <div class="skill-action-btns">
                        ${purchased ? '' : `<button class="skill-buy-btn ${canBuy ? '' : 'disabled'}" onclick="game.purchaseSkillFromDetail('${id}')">${canBuy ? 'Unlock!' : 'Cannot Afford'}</button>`}
                        <button class="skill-buy-btn" onclick="game.closeModal('skill-detail')">Close</button>
                    </div>
                `;
                this.openModal('skill-detail');
            },

            purchaseSkillFromDetail(id) {
                this.purchaseSkill(id);
                this.closeModal('skill-detail');
            },

            purchaseSkill(id) {
                const sk = SKILLS.find(s => s.id === id);
                if (!sk || this.purchasedSkills.includes(id)) return;
                if (sk.requires) {
                    const reqs = Array.isArray(sk.requires) ? sk.requires : [sk.requires];
                    if (!reqs.every(r => this.purchasedSkills.includes(r))) {
                        this.showToast(`Need prerequisites`);
                        return;
                    }
                }
                if (this.essence < sk.cost) {
                    this.showToast(`Need ${sk.cost} SP`);
                    return;
                }
                this.essence -= sk.cost;
                this.purchasedSkills.push(id);
                if (sk.stat === 'all') {
                    this.plantSpeed += 1; this.essenceMult += 1;
                    this.baseDamage += 100; this.maxHP += 500; this.hp += 500;
                } else {
                    this[sk.stat] += sk.value;
                    if (sk.stat === 'maxHP') this.hp += sk.value;
                    if (sk.stat === 'extraPlots') this.createWorld();
                }
                this.showToast(`‚ú® ${sk.name}!`);
                this.updateUI();
                this.renderSkills();
                // Update side tab if it's open
                const skillsTab = document.getElementById('skills-tab');
                if (skillsTab && skillsTab.classList.contains('expanded')) {
                    this.renderSkillsTabContent();
                }
                this.checkAchievements();
            },

            checkAchievements() {
                ACHIEVEMENTS.forEach(ach => {
                    if (!this.completedAchievements.includes(ach.id) && ach.check(this)) {
                        this.completedAchievements.push(ach.id);
                        this.essence += ach.reward;
                        this.showAchievementNotification(ach);
                        this.updateUI();
                    }
                });
            },

            showAchievementNotification(ach) {
                const notif = document.createElement('div');
                notif.className = 'achievement-notification';
                notif.innerHTML = `
                    <div class="achievement-notification-header">üèÜ ACHIEVEMENT UNLOCKED!</div>
                    <div class="achievement-notification-body">
                        <div class="achievement-notification-icon">${ach.icon}</div>
                        <div class="achievement-notification-text">
                            <div class="achievement-notification-title">${ach.name}</div>
                            <div class="achievement-notification-reward">+${ach.reward} SP</div>
                        </div>
                    </div>
                `;
                document.body.appendChild(notif);
                setTimeout(() => {
                    notif.classList.add('hiding');
                    setTimeout(() => notif.remove(), 500);
                }, 4000);
            },

            toggleTab(tabName) {
                const tab = document.getElementById(`${tabName}-tab`);
                const otherTab = tabName === 'shop' ? document.getElementById('skills-tab') : document.getElementById('shop-tab');
                
                // If already expanded, don't close it (clicking does nothing)
                if (tab.classList.contains('expanded')) {
                    return; // Do nothing - must use X button to close
                }
                
                // Close and HIDE other tab if open
                if (otherTab && otherTab.classList.contains('expanded')) {
                    otherTab.classList.remove('expanded');
                }
                if (otherTab) {
                    otherTab.classList.add('hidden'); // Hide the other tab
                }
                
                // Show and open this tab
                tab.classList.remove('hidden');
                tab.classList.add('expanded');
                
                // Render content when opening
                if (tabName === 'shop') {
                    this.renderShopContent();
                } else if (tabName === 'skills') {
                    this.renderSkillsTabContent();
                }
            },
            
            closeTab(tabName) {
                const tab = document.getElementById(`${tabName}-tab`);
                const otherTab = tabName === 'shop' ? document.getElementById('skills-tab') : document.getElementById('shop-tab');
                
                if (tab) {
                    tab.classList.remove('expanded');
                }
                
                // Show the other tab again
                if (otherTab) {
                    otherTab.classList.remove('hidden');
                }
            },
            

            sellSeed(tier) {
                if (!this.seeds[tier] || this.seeds[tier] <= 0) return;
                this.seeds[tier]--;
                const sellPrice = SEED_TIERS[tier - 1].sellPrice;
                this.essence += sellPrice;
                this.stats.totalEssenceEarned += sellPrice;
                this.xp += tier * 2;
                this.checkLevel();
                this.showToast(`üí∞ Sold T${tier} seed for ${sellPrice} SP!`);
                this.renderToolbar();
                this.renderStore();
                this.updateUI();
            },

            sellFish() {
                if (this.fishInventory <= 0) return;
                this.fishInventory--;
                const sellPrice = 150;
                this.essence += sellPrice;
                this.stats.totalEssenceEarned += sellPrice;
                this.xp += 25;
                this.checkLevel();
                this.showToast(`üí∞ Sold fish for ${sellPrice} SP!`);
                this.renderStore();
                this.updateUI();
            },

            renderShopContent() {
                const content = document.getElementById('shop-content');
                content.innerHTML = '';
                
                // Fish section
                const fishSection = document.createElement('div');
                fishSection.className = 'store-section';
                fishSection.innerHTML = `<div class="store-section-title">üêü FISH (${this.fishInventory})</div>`;
                
                if (this.fishInventory > 0) {
                    const fishItem = document.createElement('div');
                    fishItem.className = 'store-item';
                    fishItem.innerHTML = `
                        <div class="store-item-info">
                            <div class="store-item-icon">üêü</div>
                            <div class="store-item-details">
                                <div>Fish x${this.fishInventory}</div>
                                <div style="color: var(--gold);">150 SP + 25 XP</div>
                            </div>
                        </div>
                        <button class="store-sell-btn" onclick="game.sellFish()">SELL</button>
                    `;
                    fishSection.appendChild(fishItem);
                }
                content.appendChild(fishSection);
                
                // Seeds section
                const seedSection = document.createElement('div');
                seedSection.className = 'store-section';
                seedSection.innerHTML = `<div class="store-section-title">üå± SEEDS</div>`;
                
                Object.keys(this.seeds).sort((a, b) => b - a).forEach(tier => {
                    if (this.seeds[tier] > 0) {
                        const seedData = SEED_TIERS[tier - 1];
                        const seedItem = document.createElement('div');
                        seedItem.className = 'store-item';
                        seedItem.innerHTML = `
                            <div class="store-item-info">
                                <div class="store-item-icon">${seedData.icon}</div>
                                <div class="store-item-details">
                                    <div>${seedData.name} x${this.seeds[tier]}</div>
                                    <div style="color: var(--gold);">${seedData.sellPrice} SP + ${tier * 2} XP</div>
                                </div>
                            </div>
                            <button class="store-sell-btn" onclick="game.sellSeed(${tier})">SELL</button>
                        `;
                        seedSection.appendChild(seedItem);
                    }
                });
                content.appendChild(seedSection);
            },

            renderStore() {
                // Keep this for backwards compatibility - just call renderShopContent
                this.renderShopContent();
            },
            
            renderSkillsTabContent() {
                const content = document.getElementById('skills-tab-content');
                content.innerHTML = '<div class="skill-tree-scroll"><div id="skills-side-tree" class="skill-tree-container"></div></div>';
                
                const tree = document.getElementById('skills-side-tree');
                tree.innerHTML = '<div class="skill-tree-inner"></div>';
                const inner = tree.querySelector('.skill-tree-inner');
                
                // Draw VERTICAL connection lines
                SKILLS.forEach(sk => {
                    if (sk.requires) {
                        const reqs = Array.isArray(sk.requires) ? sk.requires : [sk.requires];
                        reqs.forEach(reqId => {
                            const parent = SKILLS.find(s => s.id === reqId);
                            if (parent && parent.x === sk.x) {
                                const line = document.createElement('div');
                                line.className = 'skill-line';
                                const length = sk.y - parent.y - 95;
                                line.style.width = '4px';
                                line.style.height = length + 'px';
                                line.style.left = (parent.x + 38) + 'px';
                                line.style.top = (parent.y + 95) + 'px';
                                line.style.transform = 'none';
                                if (this.purchasedSkills.includes(reqId) && this.purchasedSkills.includes(sk.id)) {
                                    line.classList.add('active');
                                }
                                inner.appendChild(line);
                            }
                        });
                    }
                });
                
                // Draw skill nodes
                SKILLS.forEach(sk => {
                    const purchased = this.purchasedSkills.includes(sk.id);
                    let canBuy = !purchased && this.essence >= sk.cost;
                    if (sk.requires) {
                        const reqs = Array.isArray(sk.requires) ? sk.requires : [sk.requires];
                        canBuy = canBuy && reqs.every(r => this.purchasedSkills.includes(r));
                    }
                    const node = document.createElement('div');
                    node.className = 'skill-node';
                    if (purchased) node.classList.add('bought');
                    else if (!canBuy) node.classList.add('locked');
                    else node.classList.add('can-buy');
                    node.style.left = sk.x + 'px';
                    node.style.top = sk.y + 'px';
                    node.innerHTML = `
                        <div class="skill-icon-sm">${sk.icon}</div>
                        <div class="skill-name-sm">${sk.name}</div>
                        ${purchased ? '<div class="skill-cost-sm">‚úÖ</div>' : `<div class="skill-cost-sm">${sk.cost}</div>`}
                    `;
                    node.onclick = (e) => {
                        e.stopPropagation();
                        this.showSkillDetail(sk.id);
                    };
                    inner.appendChild(node);
                });
            },

            updateAreaTabs() {
                // Update active state
                document.querySelectorAll('.left-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                const activeTab = document.getElementById(`${this.currentArea}-tab`);
                if (activeTab) activeTab.classList.add('active');
                
                // Show/hide astral tab
                const astralTab = document.getElementById('astral-tab');
                if (astralTab) {
                    if (this.completedAchievements.length >= ACHIEVEMENTS.filter(a => a.id !== 'true_master').length || this.unlockedAreas.astral) {
                        astralTab.style.display = 'flex';
                        astralTab.classList.remove('locked');
                    }
                }
                
                // Update locked/unlocked states for all areas
                const mineTab = document.getElementById('mine-tab');
                if (mineTab) {
                    if (!this.unlockedAreas.mine) {
                        mineTab.classList.add('locked');
                    } else {
                        mineTab.classList.remove('locked');
                    }
                }
                
                const forestTab = document.getElementById('forest-tab');
                if (forestTab) {
                    if (!this.unlockedAreas.forest) {
                        forestTab.classList.add('locked');
                    } else {
                        forestTab.classList.remove('locked');
                    }
                }
                
                const fishingTab = document.getElementById('fishing-tab');
                if (fishingTab) {
                    if (!this.unlockedAreas.fishing) {
                        fishingTab.classList.add('locked');
                    } else {
                        fishingTab.classList.remove('locked');
                    }
                }
            },

            renderToolbar() {
                const toolbar = document.getElementById('toolbar');
                toolbar.innerHTML = '';
                
                // Update left side area tabs
                this.updateAreaTabs();
                
                // Count seeds
                const seedCount = Object.keys(this.seeds).filter(t => this.seeds[t] > 0).length;
                
                // Scale down if more than 10 seed items
                const scale = seedCount > 10 ? Math.max(0.7, 1 - (seedCount - 10) * 0.05) : 1;
                
                // Only render seeds in toolbar now
                Object.keys(this.seeds).sort((a, b) => a - b).forEach(t => {
                    if (this.seeds[t] > 0) {
                        const s = SEED_TIERS[t - 1];
                        const item = document.createElement('div');
                        item.className = 'seed-item';
                        item.style.position = 'relative';
                        item.style.transform = `scale(${scale})`;
                        item.innerHTML = `<div class="seed-icon">${s.icon}</div><div class="seed-label">T${t}</div><div class="seed-count">${this.seeds[t]}</div>`;
                        const startDrag = (e) => {
                            e.preventDefault();
                            e.stopPropagation();
                            this.draggedSeed = parseInt(t);
                            this.isDragging = true;
                            this.ghostElement = document.createElement('div');
                            this.ghostElement.style.cssText = 'position:fixed; pointer-events:none; font-size:40px; z-index:9999; filter:drop-shadow(0 0 10px gold);';
                            this.ghostElement.textContent = s.icon;
                            document.body.appendChild(this.ghostElement);
                            const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                            const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                            this.ghostElement.style.left = (clientX - 20) + 'px';
                            this.ghostElement.style.top = (clientY - 20) + 'px';
                        };
                        item.addEventListener('mousedown', startDrag);
                        item.addEventListener('touchstart', startDrag);
                        toolbar.appendChild(item);
                    }
                });
                const handleDrag = (e) => {
                    if (!this.isDragging || !this.ghostElement) return;
                    e.preventDefault();
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    this.ghostElement.style.left = (clientX - 20) + 'px';
                    this.ghostElement.style.top = (clientY - 20) + 'px';
                };
                document.addEventListener('mousemove', handleDrag, { passive: false });
                document.addEventListener('touchmove', handleDrag, { passive: false });
                const handleDrop = (e) => {
                    if (!this.isDragging) return;
                    e.preventDefault();
                    if (this.ghostElement) {
                        this.ghostElement.remove();
                        this.ghostElement = null;
                    }
                    if (this.draggedSeed && this.currentArea === 'farm') {
                        const rect = this.renderer.domElement.getBoundingClientRect();
                        const clientX = e.clientX || (e.changedTouches && e.changedTouches[0].clientX);
                        const clientY = e.clientY || (e.changedTouches && e.changedTouches[0].clientY);
                        if (clientX && clientY) {
                            this.mouse.x = ((clientX - rect.left) / rect.width) * 2 - 1;
                            this.mouse.y = -((clientY - rect.top) / rect.height) * 2 + 1;
                            this.raycaster.setFromCamera(this.mouse, this.camera);
                            this.farmPlots.forEach(plot => {
                                const intersects = this.raycaster.intersectObject(plot.mesh);
                                if (intersects.length > 0 && !plot.seed) {
                                    this.plantSeed(plot, this.draggedSeed);
                                }
                            });
                        }
                    }
                    this.draggedSeed = null;
                    this.isDragging = false;
                };
                document.addEventListener('mouseup', handleDrop);
                document.addEventListener('touchend', handleDrop);
            },

            renderSkills() {
                const tree = document.getElementById('skill-tree');
                tree.innerHTML = '<div class="skill-tree-inner"></div>';
                const inner = tree.querySelector('.skill-tree-inner');
                
                // Only draw VERTICAL connection lines (no crossing lines)
                SKILLS.forEach(sk => {
                    if (sk.requires) {
                        const reqs = Array.isArray(sk.requires) ? sk.requires : [sk.requires];
                        reqs.forEach(reqId => {
                            const parent = SKILLS.find(s => s.id === reqId);
                            // Only draw line if parent is directly above (same x coordinate)
                            if (parent && parent.x === sk.x) {
                                const line = document.createElement('div');
                                line.className = 'skill-line';
                                const length = sk.y - parent.y - 95; // Height between nodes
                                line.style.width = '4px';
                                line.style.height = length + 'px';
                                line.style.left = (parent.x + 38) + 'px'; // Center of node
                                line.style.top = (parent.y + 95) + 'px'; // Bottom of parent node
                                line.style.transform = 'none';
                                if (this.purchasedSkills.includes(reqId) && this.purchasedSkills.includes(sk.id)) {
                                    line.classList.add('active');
                                }
                                inner.appendChild(line);
                            }
                        });
                    }
                });
                
                // Draw skill nodes
                SKILLS.forEach(sk => {
                    const purchased = this.purchasedSkills.includes(sk.id);
                    let canBuy = !purchased && this.essence >= sk.cost;
                    if (sk.requires) {
                        const reqs = Array.isArray(sk.requires) ? sk.requires : [sk.requires];
                        canBuy = canBuy && reqs.every(r => this.purchasedSkills.includes(r));
                    }
                    const node = document.createElement('div');
                    node.className = 'skill-node';
                    if (purchased) node.classList.add('bought');
                    else if (!canBuy) node.classList.add('locked');
                    else node.classList.add('can-buy');
                    node.style.left = sk.x + 'px';
                    node.style.top = sk.y + 'px';
                    node.innerHTML = `
                        <div class="skill-icon-sm">${sk.icon}</div>
                        <div class="skill-name-sm">${sk.name}</div>
                        ${purchased ? '<div class="skill-cost-sm">‚úÖ</div>' : `<div class="skill-cost-sm">${sk.cost}</div>`}
                    `;
                    node.onclick = (e) => {
                        e.stopPropagation();
                        this.showSkillDetail(sk.id);
                    };
                    inner.appendChild(node);
                });
            },

            renderAchievements() {
                const grid = document.getElementById('achievement-grid');
                grid.innerHTML = '';
                ACHIEVEMENTS.forEach(ach => {
                    const done = this.completedAchievements.includes(ach.id);
                    const unlocked = ach.check(this);
                    const card = document.createElement('div');
                    card.className = 'achievement-card';
                    if (done) card.classList.add('done');
                    else if (!unlocked) card.classList.add('locked');
                    card.innerHTML = `<div style="font-size: 28px; text-align: center; margin-bottom: 6px;">${ach.icon}</div><div style="font-family: 'Press Start 2P'; font-size: 7px; font-weight: bold; text-align: center; margin-bottom: 6px; color: var(--brown-dark); line-height: 1.3;">${ach.name}</div><div style="font-size: 8px; font-weight: 600; color: var(--brown-med); text-align: center; margin-bottom: 6px; line-height: 1.3;">${ach.desc}</div><div style="font-size: 8px; font-weight: bold; color: var(--gold); text-align: center;">${done ? '‚úÖ' : `${ach.reward} SP`}</div>`;
                    grid.appendChild(card);
                });
            },

            renderStats() {
                const grid = document.getElementById('stats-grid');
                grid.innerHTML = '';
                const stats = [
                    { title: 'Level', value: this.level },
                    { title: 'Total SP', value: Math.floor(this.stats.totalEssenceEarned) },
                    { title: 'Fish Inventory', value: this.fishInventory },
                    { title: 'Harvests', value: this.stats.totalHarvests },
                    { title: 'Rocks Mined', value: this.stats.totalRocksMined },
                    { title: 'Trolls Killed', value: this.stats.totalTrollsKilled },
                    { title: 'Fish Caught', value: this.stats.fishCaught },
                    { title: 'Fish Fed to Dragon', value: this.stats.fishFedToDragon },
                    { title: 'Saturns Burst', value: this.stats.saturnsBurst },
                    { title: 'Deaths', value: this.stats.deathCount },
                ];
                stats.forEach(s => {
                    const card = document.createElement('div');
                    card.style.cssText = 'background: rgba(255,255,255,0.3); border: 3px solid var(--brown-dark); border-radius: 8px; padding: 12px;';
                    card.innerHTML = `<div style="font-size: 9px; font-weight: 700; color: var(--brown-med); margin-bottom: 6px; text-transform: uppercase;">${s.title}</div><div style="font-size: 14px; font-weight: bold; color: var(--brown-dark);">${s.value}</div>`;
                    grid.appendChild(card);
                });
            },

            updateUI() {
                document.getElementById('essence-display').textContent = Math.floor(this.essence);
                document.getElementById('level-display').textContent = `LVL ${this.level}`;
                document.getElementById('hp-bar').style.width = (this.hp / this.maxHP) * 100 + '%';
                document.getElementById('hp-text').textContent = `${Math.floor(this.hp)}/${this.maxHP}`;
                document.getElementById('xp-bar').style.width = (this.xp / this.xpNeeded) * 100 + '%';
                document.getElementById('xp-text').textContent = `${Math.floor(this.xp)}/${this.xpNeeded}`;
                document.getElementById('day-night-icon').textContent = this.isDayTime ? '‚òÄÔ∏è' : 'üåô';
                document.getElementById('day-night-text').textContent = this.isDayTime ? 'Day' : 'Night';
            },

            tick() {
                // Smooth weather animation
                this.weatherParticles.forEach(p => {
                    if (p.geometry.attributes.position) {
                        const positions = p.geometry.attributes.position.array;
                        const speed = this.weather === 'rain' ? 0.2 : 0.08; // Smoother speeds
                        for (let i = 0; i < positions.length; i += 3) {
                            positions[i + 1] -= speed;
                            if (positions[i + 1] < 0) positions[i + 1] = 30;
                        }
                        p.geometry.attributes.position.needsUpdate = true;
                    }
                });
                
                if (this.currentArea === 'farm') {
                    let speedMult = this.isDayTime ? 1.4 : 0.8;
                    if (this.weather === 'rain') speedMult *= 1.25;
                    if (this.weather === 'snow') speedMult *= 0.85; // Snow slows growth by 15%
                    this.farmPlots.forEach(plot => {
                        if (plot.seed && plot.plantMesh) {
                            plot.growthTime += 100 * speedMult * (1 + this.plantSpeed);
                            const progress = Math.min(plot.growthTime / plot.growthNeeded, 1);
                            // Bigger final size: 0.3 + progress * 1.2 ‚Üí 0.4 + progress * 2.0
                            const targetScale = 0.6 + progress * 2.8; // Grows from 0.6 to 3.4 - much bigger!
                            // Smooth scale interpolation
                            const currentScale = plot.plantMesh.scale.x;
                            const newScale = currentScale + (targetScale - currentScale) * 0.1;
                            plot.plantMesh.scale.set(newScale, newScale, newScale);
                            plot.plantMesh.position.y = 0.6 + newScale * 0.45; // Higher position for bigger plants
                            const tier = plot.plantMesh.userData?.tier || 1;
                            const phase = plot.plantMesh.userData?.swayPhase || 0;
                            plot.plantMesh.rotation.z = Math.sin(Date.now() / 500 + phase) * 0.08;
                            plot.plantMesh.rotation.x = Math.sin(Date.now() / 700 + phase) * 0.04;
                            if (tier === 3 || tier === 7) {
                                plot.plantMesh.rotation.y += 0.01;
                            } else if (tier === 4 || tier === 9) {
                                plot.plantMesh.position.y += Math.sin(Date.now() / 600 + phase) * 0.05;
                            } else if (tier === 6 || tier === 10) {
                                plot.plantMesh.rotation.y += 0.02;
                            }
                            if (progress >= 1) {
                                plot.plantMesh.rotation.y += 0.05; // Faster rotation when ready!
                                // Stronger glow when fully grown - update ALL children
                                const glow = Math.sin(Date.now() / 200) * 0.5 + 1.0; // 0.5-1.5 range - VERY bright!
                                plot.plantMesh.children.forEach(child => {
                                    if (child.material && child.material.color) {
                                        child.material.emissive = child.material.color.clone();
                                        child.material.emissiveIntensity = glow;
                                    }
                                });
                            } else {
                                // Even small plants have a subtle glow
                                plot.plantMesh.children.forEach(child => {
                                    if (child.material && child.material.color) {
                                        child.material.emissive = child.material.color.clone();
                                        child.material.emissiveIntensity = 0.2 + progress * 0.3;
                                    }
                                });
                            }
                        }
                    });
                    
                    // Animate tractor driving around in circle
                    if (this.farmTractor) {
                        this.farmTractor.time += 0.01;
                        const radius = 15;
                        const x = Math.cos(this.farmTractor.time) * radius;
                        const z = Math.sin(this.farmTractor.time) * radius;
                        
                        this.farmTractor.body.position.set(x, 0.4, z);
                        this.farmTractor.cab.position.set(x, 0.9, z + 0.3);
                        this.farmTractor.body.rotation.y = this.farmTractor.time + Math.PI / 2;
                        this.farmTractor.cab.rotation.y = this.farmTractor.time + Math.PI / 2;
                        
                        this.farmTractor.wheels.forEach(w => {
                            w.mesh.position.set(x + w.offsetX * Math.cos(this.farmTractor.time + Math.PI / 2) - w.offsetZ * Math.sin(this.farmTractor.time + Math.PI / 2),
                                               0.3,
                                               z + w.offsetX * Math.sin(this.farmTractor.time + Math.PI / 2) + w.offsetZ * Math.cos(this.farmTractor.time + Math.PI / 2));
                        });
                    }
                    
                    // Rat thief mechanic (level 5+) - occasionally steals unharvested crops
                    if (this.level >= 5 && Math.random() < 0.001 && this.ratThieves.length === 0) {
                        // Find a mature crop to target
                        const maturePlots = this.farmPlots.filter(p => p.seed && p.growthTime >= p.growthNeeded);
                        if (maturePlots.length > 0) {
                            const targetPlot = maturePlots[Math.floor(Math.random() * maturePlots.length)];
                            
                            // Spawn rat thief
                            const rat = new THREE.Mesh(
                                new THREE.SphereGeometry(0.5, 10, 10),
                                new THREE.MeshLambertMaterial({ color: 0x5a5a5a, emissive: 0xff4444, emissiveIntensity: 0.7 })
                            );
                            rat.position.set(targetPlot.x + 5, 0.45, targetPlot.z);
                            this.scene.add(rat);
                            this.areaObjects.push(rat);
                            
                            // Add whiskers/ears
                            const ear1 = new THREE.Mesh(new THREE.SphereGeometry(0.16, 8, 8), new THREE.MeshLambertMaterial({ color: 0xff69b4 }));
                            ear1.position.set(targetPlot.x + 5 - 0.22, 0.7, targetPlot.z + 0.1);
                            this.scene.add(ear1);
                            this.areaObjects.push(ear1);
                            
                            const ear2 = new THREE.Mesh(new THREE.SphereGeometry(0.16, 8, 8), new THREE.MeshLambertMaterial({ color: 0xff69b4 }));
                            ear2.position.set(targetPlot.x + 5 + 0.22, 0.7, targetPlot.z + 0.1);
                            this.scene.add(ear2);
                            this.areaObjects.push(ear2);
                            
                            this.ratThieves.push({
                                mesh: rat,
                                ear1: ear1,
                                ear2: ear2,
                                x: targetPlot.x + 5,
                                z: targetPlot.z,
                                targetPlot: targetPlot,
                                state: 'running_to_crop', // 'running_to_crop', 'stealing', 'running_away', 'caught'
                                timer: 0,
                                bonusReward: 200 + this.level * 50
                            });
                        }
                    }
                    
                    // Update rat thieves
                    this.ratThieves.forEach((rat, i) => {
                        if (rat.state === 'running_to_crop') {
                            const dx = rat.targetPlot.x - rat.x;
                            rat.x += dx * 0.12; // Faster approach
                            rat.mesh.position.x = rat.x;
                            rat.ear1.position.x = rat.x - 0.2;
                            rat.ear2.position.x = rat.x + 0.2;
                            
                            if (Math.abs(dx) < 0.5) {
                                rat.state = 'stealing';
                                rat.timer = 0;
                            }
                        } else if (rat.state === 'stealing') {
                            rat.timer += 100;
                            // Bobbing animation while stealing
                            rat.mesh.position.y = 0.4 + Math.sin(Date.now() / 100) * 0.1;
                            
                            if (rat.timer >= 2000) { // Takes 2 seconds to steal
                                // Steal the crop!
                                if (rat.targetPlot.seed && rat.targetPlot.plantMesh) {
                                    rat.stolenSeedTier = rat.targetPlot.seed; // Save the seed tier
                                    this.scene.remove(rat.targetPlot.plantMesh);
                                    const idx = this.areaObjects.indexOf(rat.targetPlot.plantMesh);
                                    if (idx > -1) this.areaObjects.splice(idx, 1);
                                    rat.targetPlot.plantMesh = null;
                                    rat.targetPlot.seed = null;
                                    rat.targetPlot.growthTime = 0;
                                    this.showToast('üêÄ A rat stole your crop! Click it quick!');
                                }
                                rat.state = 'running_away';
                            }
                        } else if (rat.state === 'running_away') {
                            rat.x += 0.25; // Run away even faster
                            rat.mesh.position.x = rat.x;
                            rat.ear1.position.x = rat.x - 0.2;
                            rat.ear2.position.x = rat.x + 0.2;
                            
                            if (rat.x > 20) { // Escaped off screen
                                this.scene.remove(rat.mesh);
                                this.scene.remove(rat.ear1);
                                this.scene.remove(rat.ear2);
                                const idx1 = this.areaObjects.indexOf(rat.mesh);
                                if (idx1 > -1) this.areaObjects.splice(idx1, 1);
                                const idx2 = this.areaObjects.indexOf(rat.ear1);
                                if (idx2 > -1) this.areaObjects.splice(idx2, 1);
                                const idx3 = this.areaObjects.indexOf(rat.ear2);
                                if (idx3 > -1) this.areaObjects.splice(idx3, 1);
                                this.ratThieves.splice(i, 1);
                            }
                        }
                    });
                }
                if (this.currentArea === 'mine') {
                    this.mineRocks.forEach(rock => {
                        if (rock.hp > 0) {
                            rock.hpBarBg.lookAt(this.camera.position);
                            rock.hpBarFill.lookAt(this.camera.position);
                        }
                    });
                }
                if (this.currentArea === 'forest') {
                    // Smooth dragon animation - head rotates on neck
                    if (this.dragon && !this.dragon.isFlying) {
                        const time = Date.now() / 1000;
                        
                        // Head rotation (looking around) - stays attached via group
                        this.dragon.head.rotation.y = Math.sin(time * 0.4) * 0.4;
                        this.dragon.head.rotation.x = Math.sin(time * 0.3) * 0.15;
                        
                        // Snout follows head
                        this.dragon.snout.rotation.copy(this.dragon.head.rotation);
                        
                        // Eyes look with head
                        this.dragon.leftEye.rotation.copy(this.dragon.head.rotation);
                        this.dragon.rightEye.rotation.copy(this.dragon.head.rotation);
                        
                        // Horns follow head rotation
                        this.dragon.leftHorn.rotation.copy(this.dragon.head.rotation);
                        this.dragon.leftHorn.rotation.z -= 0.4;
                        this.dragon.rightHorn.rotation.copy(this.dragon.head.rotation);
                        this.dragon.rightHorn.rotation.z += 0.4;
                        
                        // Neck sway
                        this.dragon.neck.rotation.z = 0.2 + Math.sin(time * 0.25) * 0.15;
                        
                        // Wing flap animation
                        this.dragon.leftWing.rotation.z = 0.5 + Math.sin(time * 0.8) * 0.25;
                        this.dragon.rightWing.rotation.z = -0.5 - Math.sin(time * 0.8) * 0.25;
                    }
                    
                    this.forestTrolls.forEach(troll => {
                        if (troll.attackCooldown > 0) troll.attackCooldown -= 100;
                        if (troll.hp > 0) {
                            troll.body.rotation.y += 0.008; // Smoother rotation
                            troll.hpBarBg.lookAt(this.camera.position);
                            troll.hpBarFill.lookAt(this.camera.position);
                        }
                    });
                }
                if (this.currentArea === 'fishing') {
                    if (Math.random() < 0.02) this.spawnFish();
                    this.fishingFish.forEach((fish, i) => {
                        if (!fish.caught) {
                            // Smooth fish movement
                            const dx = fish.targetX - fish.x;
                            fish.x += dx * (fish.speed * 0.8); // Smoother movement
                            
                            // Keep fish in water (inside radius 13)
                            const distFromCenter = Math.sqrt(fish.x * fish.x + fish.z * fish.z);
                            if (distFromCenter > 13) {
                                const angle = Math.atan2(fish.z, fish.x);
                                fish.x = Math.cos(angle) * 12.5;
                                fish.z = Math.sin(angle) * 12.5;
                                fish.targetX = -fish.x; // Reverse direction
                            }
                            
                            fish.mesh.position.x = fish.x;
                            fish.mesh.position.z = fish.z;
                            fish.mesh.rotation.y = fish.x < fish.targetX ? 0 : Math.PI;
                            // Gentle bobbing
                            fish.mesh.position.y = 0.5 + Math.sin(Date.now() / 500 + i) * 0.1;
                            fish.lifetime += 100;
                            if (fish.lifetime > 8000 || Math.abs(fish.x - fish.targetX) < 0.5) {
                                this.scene.remove(fish.mesh);
                                const idx = this.areaObjects.indexOf(fish.mesh);
                                if (idx > -1) this.areaObjects.splice(idx, 1);
                                this.fishingFish.splice(i, 1);
                            }
                        }
                    });
                }
                if (this.currentArea === 'astral') {
                    this.astralSaturns.forEach(saturn => {
                        if (!saturn.burst) {
                            saturn.planet.rotation.y += 0.008; // Smoother rotation
                            saturn.ring.rotation.z += 0.015;
                            const pulse = Math.sin(Date.now() / 600) * 0.2 + 0.3; // Slower pulse
                            saturn.planet.material.emissiveIntensity = pulse;
                        }
                    });
                }
                if (this.wizard) {
                    this.updateWizardPosition();
                    this.wizard.bobOffset = Math.sin(Date.now() / 600) * 0.08; // Slower, gentler bob
                    this.wizard.body.position.x = this.wizard.baseX;
                    this.wizard.body.position.z = this.wizard.baseZ;
                    this.wizard.body.position.y = 0.7 + this.wizard.bobOffset;
                    this.wizard.face.position.x = this.wizard.baseX;
                    this.wizard.face.position.z = this.wizard.baseZ + 0.1;
                    this.wizard.face.position.y = 1.5 + this.wizard.bobOffset;
                    this.wizard.leftEye.position.x = this.wizard.baseX + 0.15;
                    this.wizard.leftEye.position.z = this.wizard.baseZ + 0.32;
                    this.wizard.leftEye.position.y = 1.52 + this.wizard.bobOffset;
                    this.wizard.rightEye.position.x = this.wizard.baseX - 0.15;
                    this.wizard.rightEye.position.z = this.wizard.baseZ + 0.32;
                    this.wizard.rightEye.position.y = 1.52 + this.wizard.bobOffset;
                    this.wizard.hat.position.x = this.wizard.baseX;
                    this.wizard.hat.position.z = this.wizard.baseZ;
                    this.wizard.hat.position.y = 2.4 + this.wizard.bobOffset;
                    this.wizard.staff.position.x = this.wizard.baseX + 0.65;
                    this.wizard.staff.position.z = this.wizard.baseZ;
                    this.wizard.staff.position.y = 0.9 + this.wizard.bobOffset;
                }
                
                // Smooth day/night color transitions
                this.updateDayNightVisuals();
            },

            animate() {
                requestAnimationFrame(() => this.animate());
                this.updateCamera();
                
                // Animate dragon - short flights every 2 minutes
                if (this.dragon && this.currentArea === 'forest') {
                    this.dragon.headTime += 0.02;
                    this.dragon.flyTime += 0.01;
                    
                    // Fly for 10 seconds every 2 minutes (120 seconds)
                    const cycleTime = this.dragon.flyTime % 120;
                    this.dragon.isFlying = cycleTime < 10; // Flying for first 10 seconds of cycle
                    
                    let bodyX = this.dragon.baseX;
                    let bodyY = 0;
                    let bodyZ = this.dragon.baseZ;
                    
                    if (this.dragon.isFlying) {
                        // Quick circle flight
                        const flyAngle = cycleTime * 0.6; // Faster rotation
                        bodyX = Math.cos(flyAngle) * this.dragon.flyRadius;
                        bodyZ = Math.sin(flyAngle) * this.dragon.flyRadius;
                        bodyY = this.dragon.flyHeight + Math.sin(cycleTime * 0.8) * 1;
                        
                        // Wing flapping
                        this.dragon.leftWing.rotation.z = Math.sin(this.dragon.flyTime * 4) * 0.6 + 0.3;
                        this.dragon.rightWing.rotation.z = -Math.sin(this.dragon.flyTime * 4) * 0.6 - 0.3;
                    } else {
                        // Landed - gentle wing movement
                        this.dragon.leftWing.rotation.z = Math.sin(this.dragon.headTime) * 0.1 + 0.3;
                        this.dragon.rightWing.rotation.z = -Math.sin(this.dragon.headTime) * 0.1 - 0.3;
                    }
                    
                    // Update all dragon parts relative to body
                    this.dragon.body.position.set(bodyX, bodyY, bodyZ);
                    this.dragon.neck.position.set(bodyX, 3 + bodyY, bodyZ - 1);
                    this.dragon.tail.position.set(bodyX, 1.5 + bodyY, bodyZ + 3);
                    this.dragon.leftWing.position.set(bodyX - 2, 2.5 + bodyY, bodyZ);
                    this.dragon.rightWing.position.set(bodyX + 2, 2.5 + bodyY, bodyZ);
                    
                    // Head movement - RELATIVE TO BODY so it stays connected
                    const offsetX = Math.sin(this.dragon.headTime) * 0.3;
                    const offsetY = Math.sin(this.dragon.headTime * 0.7) * 0.2;
                    const offsetZ = Math.cos(this.dragon.headTime * 0.5) * 0.3;
                    
                    // Head positioned relative to body, not absolute
                    this.dragon.head.position.set(
                        bodyX + offsetX,
                        bodyY + 6.0 + offsetY,
                        bodyZ - 7.5 + offsetZ
                    );
                    this.dragon.snout.position.set(
                        bodyX + offsetX,
                        bodyY + 6.0 + offsetY,
                        bodyZ - 7.5 + offsetZ + 1.2
                    );
                    this.dragon.leftEye.position.set(
                        bodyX + offsetX - 0.5,
                        bodyY + 6.0 + offsetY + 0.1,
                        bodyZ - 7.5 + offsetZ + 0.7
                    );
                    this.dragon.rightEye.position.set(
                        bodyX + offsetX + 0.5,
                        bodyY + 6.0 + offsetY + 0.1,
                        bodyZ - 7.5 + offsetZ + 0.7
                    );
                    this.dragon.leftHorn.position.set(
                        bodyX + offsetX - 0.6,
                        bodyY + 6.0 + offsetY + 0.9,
                        bodyZ - 7.5 + offsetZ + 0.3
                    );
                    this.dragon.rightHorn.position.set(
                        bodyX + offsetX + 0.6,
                        bodyY + 6.0 + offsetY + 0.9,
                        bodyZ - 7.5 + offsetZ + 0.3
                    );
                    
                    // Slight head rotation
                    this.dragon.head.rotation.y = Math.sin(this.dragon.headTime * 0.8) * 0.3;
                }
                
                this.renderer.render(this.scene, this.camera);
            },

            toggleFullscreen() {
                const container = document.getElementById('game-container');
                if (!document.fullscreenElement && container) {
                    container.requestFullscreen({ navigationUI: 'hide' }).catch(() => {});
                } else {
                    document.exitFullscreen();
                }
            },

            handleFullscreenChange() {
                const isFullscreen = !!document.fullscreenElement;
                document.body.style.overflow = isFullscreen ? 'hidden' : '';
                document.documentElement.style.overflow = isFullscreen ? 'hidden' : '';
                document.body.style.touchAction = isFullscreen ? 'none' : '';
                document.documentElement.style.touchAction = isFullscreen ? 'none' : '';

                const canvas = this.renderer && this.renderer.domElement;
                if (!canvas || !this.camera || !this.renderer) return;

                const width = isFullscreen ? window.innerWidth : canvas.clientWidth;
                const height = isFullscreen ? window.innerHeight : canvas.clientHeight;
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);
            },

            openModal(type) {
                document.getElementById(`${type}-modal`).classList.add('active');
                if (type === 'skills') this.renderSkills();
                else if (type === 'achievements') this.renderAchievements();
                else if (type === 'stats') this.renderStats();
            },

            closeModal(type) {
                document.getElementById(`${type}-modal`).classList.remove('active');
            },

            handleModalClick(event, type) {
                if (event.target.classList.contains('modal-overlay')) {
                    this.closeModal(type);
                }
            },

            showToast(msg) {
                // Only show toasts for important events, not SP gains
                if (msg.includes('+') && msg.includes('SP') && !msg.includes('üêÄ') && !msg.includes('Lost')) {
                    return; // Skip SP gain toasts
                }
                const toast = document.createElement('div');
                toast.className = 'toast';
                toast.textContent = msg;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 3000);
            },
            
            showFloatingNumber(x, y, z, amount) {
                // Create floating number in 3D space
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#FFD700';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('+' + Math.floor(amount), 64, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMat = new THREE.SpriteMaterial({ map: texture, transparent: true });
                const sprite = new THREE.Sprite(spriteMat);
                sprite.position.set(x, y + 1, z);
                sprite.scale.set(2, 1, 1);
                this.scene.add(sprite);
                
                // Animate upward and fade
                const startY = y + 1;
                const startTime = Date.now();
                const duration = 1500;
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / duration;
                    
                    if (progress < 1) {
                        sprite.position.y = startY + progress * 2;
                        sprite.material.opacity = 1 - progress;
                        requestAnimationFrame(animate);
                    } else {
                        this.scene.remove(sprite);
                        texture.dispose();
                        spriteMat.dispose();
                    }
                };
                animate();
            },
        };

        window.onload = () => game.init();
    </script>
</body>
</html>
